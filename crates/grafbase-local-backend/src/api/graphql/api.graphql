type AccessToken implements Node {
  id: ID!
  name: String!
  accountId: ID
  createdAt: DateTime!
  graphScopes: [Graph!]!
}

type AccessTokenConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AccessTokenEdge!]!
  """
  A list of nodes.
  """
  nodes: [AccessToken!]!
}

input AccessTokenCreateInput {
  name: String!
  accountId: ID
  kind: AccessTokenKind! = USER
  graphScopes: [ID!]
  projectScopes: [ID!]
}

union AccessTokenCreatePayload =
  | AccessTokenCreateSuccess
  | InvalidAccountError
  | TokenLimitExceededError
  | GraphScopeLimitExceededError
  | CouldNotFindGraphsError
  | ProjectScopeLimitExceededError
  | CouldNotFindProjectsError

type AccessTokenCreateSuccess {
  token: AccessToken!
  jwt: String!
  query: Query!
}

input AccessTokenDeleteInput {
  id: ID!
}

union AccessTokenDeletePayload = AccessTokenDeleteSuccess | TokenDoesNotExistError

type AccessTokenDeleteSuccess {
  deletedId: ID!
  query: Query!
}

"""
An edge in a connection.
"""
type AccessTokenEdge {
  """
  The item at the end of the edge
  """
  node: AccessToken!
  """
  A cursor for use in pagination
  """
  cursor: String!
}

enum AccessTokenKind {
  USER
  ACCOUNT
}

interface Account {
  id: ID!
  slug: String!
  name: String!
  plan: GrafbasePlan!
  createdAt: DateTime!
  status: AccountStatus!
  graphs(after: String, before: String, first: Int, last: Int): GraphConnection!
  graphsCountStatus: ResourceStatus!
  resources: AccountResources!
  resourcesUsageDashboard(filter: AccountResourcesUsageDashboardFilter): AccountResourcesUsageDashboardPayload!
  accessTokens(after: String, before: String, first: Int, last: Int): AccessTokenConnection!
}

input AccountCreationValidateInput {
  slug: String!
}

type AccountCreationValidatePayload {
  slugAvailable: Boolean!
}

type AccountDoesNotExistError {
  query: Query!
}

type AccountDopplerIntegration {
  accessToken: String!
}

input AccountDopplerIntegrationInput {
  accessToken: String!
}

type AccountIntegration {
  accountId: ID!
  createdAt: DateTime!
  enabled: Boolean!
  id: ID!
  environments: [BranchEnvironment!]!
  integrationId: ID!
  attributes: AccountIntegrationAttributes!
  graphs: [GraphIntegration!]!
}

union AccountIntegrationAttributes = DatadogIntegration | AccountDopplerIntegration

input AccountIntegrationAttributesInput @oneOf {
  datadog: DatadogIntegrationInput
  doppler: AccountDopplerIntegrationInput
}

input AccountIntegrationInput {
  enabled: Boolean!
  graphs: [ID!]
  environments: [BranchEnvironment!]
  attributes: AccountIntegrationAttributesInput!
}

type AccountIntegrationMutationError {
  message: String!
  query: Query!
}

union AccountIntegrationMutationPayload = AccountIntegrationMutationSuccess | AccountIntegrationMutationError

type AccountIntegrationMutationSuccess {
  account: Account!
  query: Query!
}

type AccountResources {
  graphs: ResourceStatus!
}

type AccountResourcesStatus {
  requestCount: ResourceStatus!
}

type AccountResourcesUsage {
  requestCount: TimeSeries!
  granularity: TimeAggregationGranularity!
}

"""
'limit_cycle_choice' is exclusive with all other options. It's the only case
where we'll show account limit status (used/limit)
"""
input AccountResourcesUsageDashboardFilter {
  projectIds: [ID!]
  graphIds: [ID!]
  limitCycleChoice: LimitCycleChoice
  startDate: DateTime
  endDate: DateTime
}

type AccountResourcesUsageDashboardInvalidFilterCombinationError {
  message: String!
  query: Query!
}

union AccountResourcesUsageDashboardPayload =
  | AccountResourcesUsageDashboardSuccess
  | AccountResourcesUsageDashboardInvalidFilterCombinationError

type AccountResourcesUsageDashboardSuccess {
  periodStart: DateTime!
  periodEnd: DateTime!
  usage: AccountResourcesUsage!
  status: AccountResourcesStatus
}

type AccountStatus {
  isEnabled: Boolean!
  inArrearsCause: InArrearsCause
  hasExceededLimits: Boolean!
  isHobbyPlanEnforced: Boolean!
}

type AlreadyExistsError {
  query: Query!
}

type AlreadyMemberError {
  query: Query!
}

type ArchiveFileSizeLimitExceededError {
  query: Query!
  limit: Int!
}

type Branch implements Node {
  id: ID!
  name: String!
  domains: [String!]!
  latestDeployment: Deployment
  activeDeployment: Deployment
  deployments(after: String, before: String, first: Int, last: Int): DeploymentConnection!
  graph: Graph!
  environment: BranchEnvironment!
  schema: String
  federatedSchema: String
  operationChecksEnabled: Boolean!
  schemaProposals(first: Int, after: String, filter: SchemaProposalFilter!): SchemaProposalConnection!
  schemaProposalsConfiguration: SchemaProposalsConfiguration!
  subgraphs: [Subgraph!]!
  endpointConfig: EndpointConfig
}

type BranchAlreadyExistsError {
  query: Query!
}

type BranchConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BranchEdge!]!
  """
  A list of nodes.
  """
  nodes: [Branch!]!
}

input BranchCreateInput {
  accountSlug: String!
  graphSlug: String!
  branchName: String!
}

union BranchCreatePayload = Query | BranchAlreadyExistsError | GraphDoesNotExistError | GraphNotSelfHostedError

union BranchDeletePayload = Query | BranchDoesNotExistError | CannotDeleteProductionBranchError

type BranchDoesNotExistError {
  query: Query!
}

"""
An edge in a connection.
"""
type BranchEdge {
  """
  The item at the end of the edge
  """
  node: Branch!
  """
  A cursor for use in pagination
  """
  cursor: String!
}

enum BranchEnvironment {
  PREVIEW
  PRODUCTION
}

input BranchUpdateInput {
  accountSlug: String!
  projectSlug: String
  graphSlug: String
  branchSlug: String!
  trustedDocumentsEnforce: Boolean
  trustedDocumentsBypassHeaderName: String
  trustedDocumentsBypassHeaderValue: String
  operationChecksEnabled: Boolean
  schemaProposalsConfiguration: SchemaProposalsConfigurationUpdateInput
}

union BranchUpdatePayload = Query | ProjectDoesNotExistError | GraphDoesNotExistError

type CannotBeRenamedError {
  query: Query!
}

type CannotDeleteProductionBranchError {
  query: Query!
}

type CannotUseInvitationsWithSSO {
  query: Query!
}

type CompositionCheckError {
  title: String!
  message: String!
}

type CouldNotFindGraphsError {
  unknownGraphIds: [ID!]!
}

type CouldNotFindProjectsError {
  unknownProjectIds: [ID!]!
}

type CurrentPlanLimitReachedError {
  max: Int!
  query: Query!
}

type DailyDeploymentCountLimitExceededError {
  query: Query!
  limit: Int!
}

type DatadogIntegration {
  apiKey: String!
  region: DatadogRegion!
  """
  Deprecated: environments moved one level up, on AccountIntegration
  """
  environments: [BranchEnvironment!]!
  sampling: Int!
}

input DatadogIntegrationInput {
  apiKey: String!
  region: DatadogRegion!
  sampling: Int!
}

enum DatadogRegion {
  US1
  US3
  US5
  EU1
  US1_FED
  AP1
}

"""
RFC3339 formatted date in the UTC time zone denoted by letter 'Z'
"""
scalar DateTime

input DeleteSubgraphInput {
  accountSlug: String!
  graphSlug: String
  projectSlug: String
  branch: String!
  subgraph: String!
  message: String
  dryRun: Boolean!
}

union DeleteSubgraphPayload =
  | DeleteSubgraphSuccess
  | SubgraphNotFoundError
  | ProjectDoesNotExistError
  | ProjectNotFederatedError
  | ProjectBranchDoesNotExistError
  | GraphDoesNotExistError
  | GraphNotFederatedError
  | GraphBranchDoesNotExistError
  | FederatedGraphCompositionError

type DeleteSubgraphSuccess {
  query: Query!
}

"""
Deployment
"""
type Deployment implements Node {
  id: ID!
  branch: Branch!
  createdAt: DateTime!
  startedAt: DateTime
  finishedAt: DateTime
  isRedeployable: Boolean!
  triggerType: DeploymentTriggerType!
  """
  The duration of the deployment in milliseconds.
  """
  duration: Int
  status: DeploymentStatus!
  graph: Graph!
  schema: String
  diffAgainstPreviousBranchDeployment: String
  diffAgainstLatestProductionDeployment: String
}

input DeploymentBySlugCreateInput {
  accountSlug: String!
  graphSlug: String
  projectSlug: String
  archiveFileSize: Int!
  branch: String
}

type DeploymentConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [DeploymentEdge!]!
  """
  A list of nodes.
  """
  nodes: [Deployment!]!
}

input DeploymentCreateInput {
  graphId: ID
  projectId: ID
  archiveFileSize: Int!
  branch: String
}

union DeploymentCreatePayload =
  | DeploymentCreateSuccess
  | ProjectDoesNotExistError
  | ArchiveFileSizeLimitExceededError
  | DailyDeploymentCountLimitExceededError
  | ProjectNotManagedError
  | ProjectNotStandaloneError
  | GraphDoesNotExistError
  | GraphNotManagedError
  | GraphNotStandaloneError
  | NotAllowedError

type DeploymentCreateSuccess {
  deployment: Deployment!
  presignedUrl: String!
  query: Query!
}

type DeploymentDoesNotExistError {
  query: Query!
}

"""
An edge in a connection.
"""
type DeploymentEdge {
  """
  The item at the end of the edge
  """
  node: Deployment!
  """
  A cursor for use in pagination
  """
  cursor: String!
}

input DeploymentFilter {
  branch: String
  statuses: [DeploymentStatus!]
}

union DeploymentRedeployPayload =
  | DeploymentRedeploySuccess
  | DeploymentDoesNotExistError
  | DailyDeploymentCountLimitExceededError
  | NotAllowedError

type DeploymentRedeploySuccess {
  deployment: Deployment!
  query: Query!
}

enum DeploymentStatus {
  QUEUED
  IN_PROGRESS
  SUCCEEDED
  FAILED
}

enum DeploymentTriggerType {
  GRAPH_CREATION
  PROJECT_CREATION @deprecated(reason: "replaced by GraphCreation")
  GIT_PUSH
  CLI
  REDEPLOYMENT
  NEW_SCHEMA_PUBLICATION
  INTERNAL
}

type DiffSnippet {
  originalSchemaSnippet: String!
  originalSchemaSnippetFirstLine: Int!
  proposedSchemaSnippet: String!
  proposedSchemaSnippetFirstLine: Int!
  addedLines: [Int!]!
  removedLines: [Int!]!
}

type DisabledAccountError {
  query: Query!
}

type DopplerConfig {
  name: String!
  projectName: String!
}

type DopplerProject {
  name: String!
}

type DuplicateDatabaseRegionsError {
  duplicates: [String!]!
  query: Query!
}

"""
Implement the Duration scalar

The input/output is a string in ISO8601 format.
"""
scalar Duration

input DurationFilter {
  lt: Duration
  lte: Duration
  gt: Duration
  gte: Duration
}

type EmptyDatabaseRegionsError {
  query: Query!
}

type EndpointConfig {
  url: String!
}

input EndpointConfigInput {
  url: String!
}

input EndpointConfigUpdateInput {
  accountSlug: String!
  graphSlug: String!
  branchSlug: String!
  endpointConfig: EndpointConfigInput!
}

union EndpointConfigUpdatePayload = Query | GraphDoesNotExistError

type ErrorCountByCode {
  code: String!
  count: Int!
}

type FederatedGraphCompositionError {
  query: Query!
  messages: [String!]!
}

type FieldAnalytics {
  metrics: FieldMetricsTimeSeries
  topClients(
    """
    Detaults to 10, Max 100
    """
    limit: Int
    """
    Search over the client names/versions
    """
    searchQuery: String
  ): TopClientsForField
}

type FieldMetrics {
  count: Int!
}

type FieldMetricsTimeSeries {
  overall: FieldMetrics!
  points: [FieldMetricsTimeSeriesDataPoint!]!
  previousPeriod: FieldMetricsTimeSeries
}

type FieldMetricsTimeSeriesDataPoint {
  dateTime: DateTime!
  count: Int!
}

enum FunctionKind {
  AUTHORIZER
  RESOLVER
}

type FunctionLogEvent implements LogEvent {
  id: String!
  branch: String!
  environment: BranchEnvironment!
  deploymentId: ID!
  createdAt: DateTime!
  functionKind: FunctionKind!
  functionName: String!
  region: String!
  logLevel: LogLevel!
  url: String
  message: String!
}

type GatewayRequestLogEvent implements LogEvent {
  id: String!
  branch: String!
  environment: BranchEnvironment!
  deploymentId: ID!
  createdAt: DateTime!
  region: String!
  logLevel: LogLevel!
  httpMethod: String!
  httpStatus: Int!
  url: String!
  operation: GatewayRequestLogEventOperation
  duration: Int!
  message: String!
}

type GatewayRequestLogEventOperation {
  name: String
  type: OperationType!
}

enum GrafbasePlan {
  HOBBY @deprecated(reason: "to be removed soon")
  PRO @deprecated(reason: "to be removed soon")
  TRIAL
  ENTERPRISE
}

type Graph implements Node {
  id: ID!
  slug: String!
  graphType: GraphType
  graphMode: GraphMode!
  createdAt: DateTime!
  canBeRenamed: Boolean!
  status: GraphStatus!
  owners: [Team!]!
  account: Account!
  branches(after: String, before: String, first: Int, last: Int): BranchConnection!
  apiKeys(after: String, before: String, first: Int, last: Int): GraphApiKeyConnection!
  productionBranch: Branch!
  deployments(after: String, before: String, first: Int, last: Int, filter: DeploymentFilter): DeploymentConnection!
  schemaChecks(first: Int, after: String, branch: String): SchemaCheckConnection!
  schemaProposals(after: String, first: Int): SchemaProposalConnection!
  operationChecksConfiguration: GraphOperationCheckConfiguration!
  logEvents(first: Int, after: String, last: Int, before: String, filter: LogEventFilter!): LogEventConnection!
  analytics(filters: GraphAnalyticsFilters!): GraphAnalytics
  requests(first: Int, last: Int, before: String, after: String, filters: RequestFilters!): RequestConnection
  request(
    branchName: String
    """
    The approximate timestamp of the request, within a few minutes of the actual request.
    """
    approximateTimestamp: DateTime!
    traceId: ID!
  ): Request
  requestAnalytics(filter: GraphRequestAnalyticsFilter!): RequestAnalytics
    @deprecated(reason: "Use `analytics` instead")
}

union GraphAddOwnerPayload = GraphAddOwnerSuccess | GraphDoesNotExistError | NotAllowedError

type GraphAddOwnerSuccess {
  query: Query!
}

type GraphAnalytics {
  forField(
    """
    Schema path defined as: '<parent-type-name>.<name>'
    """
    schemaPath: String!
  ): FieldAnalytics!
  requestMetrics(
    """
    Latency percentiles to retrieve. Ex: [50, 99, 99.9]
    """
    latencyPercentiles: [Float!]
  ): RequestMetricsTimeSeriesV2
  topOperations(
    """
    If not specified, top operations by latency will be empty. Ex: 95
    """
    latencyPercentile: Float
    """
    Detaults to 10, Max 100
    """
    limit: Int
    """
    Search over the opeartion names
    """
    searchQuery: String
  ): TopOperations
  topClients(
    """
    If not specified, top clients by latency will be empty. Ex: 95
    """
    latencyPercentile: Float
    """
    Detaults to 10, Max 100
    """
    limit: Int
    """
    Search over the client names/versions
    """
    searchQuery: String
  ): TopClients
}

input GraphAnalyticsFilters {
  """
  Defaults to production branch
  """
  branchName: String
  """
  Use this if you really care about having a specific duration like 1 hour, 7 days, etc.
  """
  range: Duration
  """
  Use this if you *at least* the data between `from` and `to` to be provided. You may get
  more, but never less.
  """
  from: DateTime
  """
  To be used in conjunction with with either `range` or `from`.
  """
  to: DateTime!
  """
  If explicitly to false, specifying both `from` and `to` will be treated as if `range: (to - from)`
  had been specified instead. Meaning only the duration between `from` and `to` matters, not
  necessarily having a data point for `from` itself.
  """
  isCustomRange: Boolean
  """
  If specified, overrides approximateNumberOfPoints. Must be in whole minutes.
  At most 150 points can be returned.
  """
  aggregationStep: Duration
  """
  Defaults to 100, at most 150 points can be returned.
  """
  approximateNumberOfDataPoints: Int
  """
  Defaults to true
  Example: for an aggregationStep of 15 min:
  - if true, only times with 00, 15, 30 and 45 minutes will appear in the time series
  - if false, times in the time series will be adjusted to start from the periodStart (~from).
  So if from = 15:32:00, times will end in 02, 17, 32 and 47.
  I'll always align to the aggregation step used to store the data though, which
  is currently in minutes. So cannot have 15:10:20, 15:11:20, etc.
  """
  alignPeriodWithAggregationStep: Boolean
  operationName: String
  """
  Only used if operation name is specified.
  """
  operationNormalizedQueryHash: OperationNormalizedQueryHash
  clientName: String
  """
  Only used if client name is specified.
  """
  clientVersion: String
}

type GraphApiKey implements Node {
  id: ID!
  key: String!
  environment: BranchEnvironment!
  createdAt: DateTime!
  name: String!
}

type GraphApiKeyConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [GraphApiKeyEdge!]!
  """
  A list of nodes.
  """
  nodes: [GraphApiKey!]!
}

input GraphApiKeyCreateInput {
  graphId: ID!
  environment: BranchEnvironment!
  name: String!
}

union GraphApiKeyCreatePayload = GraphApiKeyCreateSuccess | KeyLimitExceededError | GraphDoesNotExistError

type GraphApiKeyCreateSuccess {
  apiKey: GraphApiKey!
  query: Query!
}

input GraphApiKeyDeleteInput {
  id: ID!
}

union GraphApiKeyDeletePayload =
  | GraphApiKeyDeleteSuccess
  | KeyDoesNotExistError
  | MustLeaveAtLeastOneKeyForEnvironmentError

type GraphApiKeyDeleteSuccess {
  deletedId: ID!
  query: Query!
}

"""
An edge in a connection.
"""
type GraphApiKeyEdge {
  """
  The item at the end of the edge
  """
  node: GraphApiKey!
  """
  A cursor for use in pagination
  """
  cursor: String!
}

input GraphApiKeyUpdateInput {
  id: ID!
  name: String!
}

union GraphApiKeyUpdatePayload = GraphApiKeyUpdateSuccess | KeyDoesNotExistError

type GraphApiKeyUpdateSuccess {
  query: Query!
}

type GraphBranchDoesNotExistError {
  query: Query!
}

type GraphConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [GraphEdge!]!
  """
  A list of nodes.
  """
  nodes: [Graph!]!
}

input GraphCreateInput {
  accountId: ID!
  graphSlug: String!
  graphMode: GraphMode! = SELF_HOSTED
  graphType: GraphType
}

union GraphCreatePayload =
  | GraphCreateSuccess
  | AccountDoesNotExistError
  | CurrentPlanLimitReachedError
  | DisabledAccountError
  | DuplicateDatabaseRegionsError
  | EmptyDatabaseRegionsError
  | InvalidDatabaseRegionsError
  | InvalidRepoRootPathError
  | SlugAlreadyExistsError
  | SlugInvalidError
  | SlugTooLongError
  | StandaloneGraphsNoLongerSupportedError
  | ManagedGraphsNoLongerSupportedError

type GraphCreateSuccess {
  graph: Graph!
  query: Query!
}

input GraphDeleteInput {
  id: ID!
}

union GraphDeletePayload = GraphDeleteSuccess | GraphDoesNotExistError

type GraphDeleteSuccess {
  query: Query!
}

type GraphDoesNotExistError {
  query: Query!
}

input GraphDopplerIntegrationAttributesInput {
  projectName: String!
  configName: String!
}

"""
An edge in a connection.
"""
type GraphEdge {
  """
  The item at the end of the edge
  """
  node: Graph!
  """
  A cursor for use in pagination
  """
  cursor: String!
}

type GraphIntegration {
  accountIntegrationId: ID!
  createdAt: DateTime!
  enabled: Boolean!
  id: ID!
  branch: Branch
  graph: Graph!
  attributes: GraphIntegrationAttributes
}

union GraphIntegrationAttributes = ProjectDopplerIntegration

input GraphIntegrationAttributesInput @oneOf {
  doppler: GraphDopplerIntegrationAttributesInput
}

input GraphIntegrationInput {
  enabled: Boolean!
  attributes: GraphIntegrationAttributesInput
  branch: ID
}

type GraphIntegrationMutationError {
  message: String!
  query: Query!
}

union GraphIntegrationMutationPayload = GraphIntegrationMutationSuccess | GraphIntegrationMutationError

type GraphIntegrationMutationSuccess {
  account: Account!
  query: Query!
}

enum GraphMode {
  MANAGED @deprecated(reason: "to be removed soon")
  SELF_HOSTED
}

type GraphNotFederatedError {
  query: Query!
}

type GraphNotManagedError {
  query: Query!
}

type GraphNotSelfHostedError {
  query: Query!
}

type GraphNotStandaloneError {
  query: Query!
}

type GraphOperationCheckConfiguration {
  """
  The time range in days to consider for operation checks. Operations older than the specificied
  number of days are ignored.
  """
  timeRangeDays: Int!
  """
  The request count threshold to consider for operation checks. Operations that have been
  registered less than the specified number of occurrences are ignored.
  """
  requestCountThreshold: Int!
  """
  The clients to exclude from operation checks.
  """
  excludedClients: [String!]!
  """
  The operations to exclude from operation checks.
  """
  excludedOperations: [String!]!
}

input GraphOperationCheckConfigurationInput {
  """
  The graph to update.
  """
  graphId: ID!
  """
  Whether operation checks are enabled for the graph. This is ignored, since operation checks are now only enabled at the branch level.
  """
  enabled: Boolean
  """
  The time range in days to consider for operation checks. Operations older than the specificied
  number of days are ignored.
  """
  timeRangeDays: Int
  """
  The request count threshold to consider for operation checks. Operations that have been
  registered less than the specified number of occurrences are ignored.
  """
  requestCountThreshold: Int
  """
  The clients to exclude from operation checks.
  """
  excludedClients: [String!]
  """
  The operations to exclude from operation checks.
  """
  excludedOperations: [String!]
}

union GraphOperationCheckConfigurationUpdatePayload =
  | GraphDoesNotExistError
  | GraphOperationCheckConfiguration
  | NotAllowedError

union GraphRemoveOwnerPayload = GraphRemoveOwnerSuccess | GraphDoesNotExistError | NotAllowedError

type GraphRemoveOwnerSuccess {
  query: Query!
}

input GraphRequestAnalyticsFilter {
  branch: String = null
  period: GraphRequestAnalyticsPeriod
  now: DateTime
  from: DateTime
  to: DateTime
  aggregationStep: Duration
  approximateNumberOfDataPoints: Int
  alignPeriodWithAggregationStep: Boolean
  graphqlOperation: String
  operationId: ID
  clientName: String
  clientVersion: String
}

enum GraphRequestAnalyticsPeriod {
  LAST_HOUR
  LAST_24_HOURS
  LAST_7_DAYS
}

type GraphScopeLimitExceededError {
  query: Query!
}

enum GraphStatus {
  ACTIVE
  INACTIVE
}

enum GraphType {
  STANDALONE @deprecated(reason: "to be removed soon")
  FEDERATED
}

input GraphUpdateInput {
  id: ID!
  graphSlug: String
  productionBranch: String
}

union GraphUpdatePayload =
  | GraphUpdateSuccess
  | CannotBeRenamedError
  | GraphDoesNotExistError
  | NotAllowedError
  | SlugAlreadyExistsError
  | SlugInvalidError
  | SlugTooLongError

type GraphUpdateSuccess {
  graph: Graph!
  query: Query!
}

enum InArrearsCause {
  NEVER_PAID
  UNPAID_INVOICE
}

type Integration {
  id: ID!
  name: String!
  createdAt: DateTime!
}

type InvalidAccountError {
  query: Query!
}

type InvalidDatabaseRegionsError {
  invalid: [String!]!
  query: Query!
}

type InvalidRepoRootPathError {
  query: Query!
}

type Invite implements Node {
  id: ID!
  role: MemberRole!
  email: String!
  invitedBy: User!
  lastRenewedAt: DateTime!
  status: InviteStatus!
  createdAt: DateTime!
  organization: Organization!
}

input InviteAcceptInput {
  id: ID!
}

union InviteAcceptPayload =
  | InviteAcceptSuccess
  | InviteDoesNotExistError
  | AlreadyMemberError
  | CannotUseInvitationsWithSSO

type InviteAcceptSuccess {
  member: Member!
  query: Query!
}

input InviteCancelInput {
  id: ID!
}

union InviteCancelPayload = InviteCancelSuccess | InviteDoesNotExistError | NotAllowedToCancelInvitesError

type InviteCancelSuccess {
  inviteId: ID!
  query: Query!
}

type InviteConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [InviteEdge!]!
  """
  A list of nodes.
  """
  nodes: [Invite!]!
}

input InviteDeclineInput {
  id: ID!
}

union InviteDeclinePayload = InviteDeclineSuccess | InviteDoesNotExistError

type InviteDeclineSuccess {
  inviteId: ID!
  query: Query!
}

type InviteDoesNotExistError {
  query: Query!
}

"""
An edge in a connection.
"""
type InviteEdge {
  """
  The item at the end of the edge
  """
  node: Invite!
  """
  A cursor for use in pagination
  """
  cursor: String!
}

input InviteSendInput {
  organizationId: ID!
  email: String!
  role: MemberRole!
}

union InviteSendPayload =
  | InviteSendSuccess
  | OrganizationDoesNotExistError
  | NotAllowedToSendInvitesError
  | CannotUseInvitationsWithSSO

type InviteSendSuccess {
  invite: Invite!
  query: Query!
}

enum InviteStatus {
  PENDING
  EXPIRED
}

"""
A scalar that can represent any JSON value.
"""
scalar JSON

type KeyDoesNotExistError {
  query: Query!
}

type KeyLimitExceededError {
  query: Query!
}

"""
Users can select the previous/current "limit cycle" which defines the cycle on which limits
applies. For hobby it's monthly starting the first of each month and for pro it matches the
billing cycle.
"""
enum LimitCycleChoice {
  CURRENT
  PREVIOUS
}

type LintCheckError {
  title: String!
  message: String!
  severity: SchemaCheckErrorSeverity!
}

interface LogEvent {
  id: String!
  createdAt: DateTime!
  region: String!
  logLevel: LogLevel!
  deploymentId: ID!
  branch: String!
  environment: BranchEnvironment!
  message: String!
}

type LogEventConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [LogEventEdge!]!
  """
  A list of nodes.
  """
  nodes: [LogEvent!]!
}

"""
An edge in a connection.
"""
type LogEventEdge {
  """
  The item at the end of the edge
  """
  node: LogEvent!
  """
  A cursor for use in pagination
  """
  cursor: String!
}

input LogEventFilter {
  query: String
  branch: String
  from: DateTime
  to: DateTime
  region: [String!]
  logLevel: [LogLevel!]
}

enum LogLevel {
  DEBUG
  INFO
  WARN
  ERROR
}

type ManagedGraphsNoLongerSupportedError {
  query: Query!
}

type Member implements Node {
  id: ID!
  role: MemberRole!
  createdAt: DateTime!
  account: Account!
  user: User!
}

type MemberConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [MemberEdge!]!
  """
  A list of nodes.
  """
  nodes: [Member!]!
}

input MemberDeleteInput {
  id: ID!
}

type MemberDeletePayload {
  deletedMemberId: ID!
  query: Query!
}

"""
An edge in a connection.
"""
type MemberEdge {
  """
  The item at the end of the edge
  """
  node: Member!
  """
  A cursor for use in pagination
  """
  cursor: String!
}

enum MemberRole {
  OWNER
  MEMBER
  ADMIN
}

input MemberUpdateInput {
  id: ID!
  role: MemberRole
}

type MemberUpdatePayload {
  member: Member!
  query: Query!
}

type MustLeaveAtLeastOneKeyForEnvironmentError {
  query: Query!
}

type Mutation {
  """
  Create a new access token.
  """
  accessTokenCreate(input: AccessTokenCreateInput!): AccessTokenCreatePayload!
  """
  Delete a given access token.
  """
  accessTokenDelete(input: AccessTokenDeleteInput!): AccessTokenDeletePayload!
  accountIntegrationCreate(accountId: ID!, input: AccountIntegrationInput!): AccountIntegrationMutationPayload!
  accountIntegrationUpdate(id: ID!, input: AccountIntegrationInput!): AccountIntegrationMutationPayload!
  accountIntegrationDelete(id: ID!): AccountIntegrationMutationPayload!
  """
  Create new organization account owned by the current user. Slug must be unique.
  """
  organizationCreate(input: OrganizationCreateInput!): OrganizationCreatePayload!
  organizationSlugUpdate(input: OrganizationSlugUpdateInput!): OrganizationSlugUpdatePayload!
  personalAccountSlugUpdate(input: PersonalAccountSlugUpdateInput!): PersonalAccountSlugUpdatePayload!
  organizationUpdate(input: OrganizationUpdateInput!): OrganizationUpdatePayload!
  personalAccountUpdate(input: PersonalAccountUpdateInput!): PersonalAccountUpdatePayload!
    @deprecated(reason: "to be removed")
  personalAccountDelete: PersonalAccountDeletePayload! @deprecated(reason: "to be removed")
  organizationDelete(input: OrganizationDeleteInput!): OrganizationDeletePayload!
  branchCreate(input: BranchCreateInput!): BranchCreatePayload!
  branchUpdate(input: BranchUpdateInput!): BranchUpdatePayload!
  branchDelete(
    """
    slug of the account
    """
    accountSlug: String!
    """
    slug of the graph
    """
    graphSlug: String
    """
    slug of the project
    """
    projectSlug: String
    """
    name of the branch
    """
    branchName: String!
  ): BranchDeletePayload!
  endpointConfigUpdate(input: EndpointConfigUpdateInput!): EndpointConfigUpdatePayload!
  branchSchemaProposalsConfiguredReviewerAdd(
    input: SchemaProposalsConfiguredReviewerAddInput!
  ): SchemaProposalsConfiguredReviewerAddPayload!
  branchSchemaProposalsConfiguredReviewerRemove(
    input: SchemaProposalsConfiguredReviewerRemoveInput!
  ): SchemaProposalsConfiguredReviewerRemovePayload!
  """
  Create a new deployment for an existing graph by slugs.
  """
  deploymentCreateBySlug(input: DeploymentBySlugCreateInput!): DeploymentCreatePayload!
    @deprecated(reason: "this mutation will be removed")
  """
  Create a new deployment for an existing graph.
  """
  deploymentCreate(input: DeploymentCreateInput!): DeploymentCreatePayload!
    @deprecated(reason: "this mutation will be removed")
  """
  Create a new deployment for an existing graph.
  """
  deploymentRedeploy(
    """
    ID of the deployment
    """
    id: ID!
  ): DeploymentRedeployPayload!
  """
  Create a new graph API key.
  """
  graphApiKeyCreate(input: GraphApiKeyCreateInput!): GraphApiKeyCreatePayload!
  """
  Update a given API key with a new name.
  """
  graphApiKeyUpdate(input: GraphApiKeyUpdateInput!): GraphApiKeyUpdatePayload!
  """
  Delete a given API key.
  """
  graphApiKeyDelete(input: GraphApiKeyDeleteInput!): GraphApiKeyDeletePayload!
  graphIntegrationCreate(
    accountIntegrationId: ID!
    graphId: ID!
    input: GraphIntegrationInput!
  ): GraphIntegrationMutationPayload!
  graphIntegrationUpdate(id: ID!, input: GraphIntegrationInput!): GraphIntegrationMutationPayload!
  graphIntegrationDelete(id: ID!): GraphIntegrationMutationPayload!
  """
  Create a new graph without any source for an initial deployment.
  """
  graphCreate(input: GraphCreateInput!): GraphCreatePayload!
  graphUpdate(input: GraphUpdateInput!): GraphUpdatePayload!
  graphOperationCheckConfigurationUpdate(
    input: GraphOperationCheckConfigurationInput!
  ): GraphOperationCheckConfigurationUpdatePayload!
  graphDelete(input: GraphDeleteInput!): GraphDeletePayload!
  graphAddOwner(graphId: ID!, ownerId: ID!): GraphAddOwnerPayload!
  graphRemoveOwner(graphId: ID!, ownerId: ID!): GraphRemoveOwnerPayload!
  inviteSend(input: InviteSendInput!): InviteSendPayload!
  inviteCancel(input: InviteCancelInput!): InviteCancelPayload!
  inviteAccept(input: InviteAcceptInput!): InviteAcceptPayload!
  inviteDecline(input: InviteDeclineInput!): InviteDeclinePayload!
  """
  Update role of an organization member
  """
  memberUpdate(input: MemberUpdateInput!): MemberUpdatePayload!
  """
  Remove member from an organization
  """
  memberDelete(input: MemberDeleteInput!): MemberDeletePayload!
  """
  Run checks against the given schema
  """
  schemaCheckCreate(input: SchemaCheckCreateInput!): SchemaCheckPayload!
  schemaProposalCreate(input: SchemaProposalCreateInput!): SchemaProposalCreatePayload!
  schemaProposalRequestReview(input: SchemaProposalRequestReviewInput!): SchemaProposalRequestReviewPayload!
  schemaProposalApprove(input: SchemaProposalApproveInput!): SchemaProposalApprovePayload!
  schemaProposalReject(input: SchemaProposalRejectInput!): SchemaProposalRejectPayload!
  schemaProposalDelete(id: ID!): SchemaProposalDeletePayload!
  """
  Edit the contents of a proposal.

  The proposed subgraphs can be just a subset of the subgraphs being edited in the proposal. The changes from the previous edit on other subgraphs be carried over.
  """
  schemaProposalEdit(input: SchemaProposalEditInput!): SchemaProposalEditPayload!
  schemaProposalCommentThreadCreate(
    input: SchemaProposalCommentThreadCreateInput!
  ): SchemaProposalCommentThreadCreatePayload!
  """
  Mark a comment thread as resolved.
  """
  schemaProposalCommentThreadResolve(rootCommentId: ID!): SchemaProposalCommentThreadResolvePayload!
  schemaProposalCommentReply(parentCommentId: ID!, text: String!): SchemaProposalCommentReplyPayload!
  """
  Reverts the resolution of a comment thread.
  """
  schemaProposalCommentThreadUnresolve(rootCommentId: ID!): SchemaProposalCommentThreadUnresolvePayload!
  """
  Request a review for a schema proposal from a user or a team.
  """
  schemaProposalReviewRequestCreate(
    input: SchemaProposalReviewRequestCreateInput!
  ): SchemaProposalReviewRequestCreatePayload!
  """
  Publish a new subgraph.
  """
  publish(input: PublishInput!): PublishPayload!
  """
  Delete a subgraph
  """
  deleteSubgraph(input: DeleteSubgraphInput!): DeleteSubgraphPayload!
  slackIntegrationCreate(input: SlackIntegrationCreateInput!): SlackNotificationCreatePayload!
  slackNotificationDelete(id: String!): SlackNotificationDeletePayload!
  """
  Assign a team as the owner of a subgraph
  """
  subgraphAddOwner(branchId: ID!, subgraphName: String!, owner: ID!): SubgraphAddOwnerPayload!
  """
  Unassign a team's ownership of a subgraph
  """
  subgraphRemoveOwner(branchId: ID!, subgraphName: String!): SubgraphRemoveOwnerPayload!
  teamCreate(organizationId: ID!, name: String!): TeamCreatePayload!
  teamDelete(teamId: ID!): TeamDeletePayload!
  teamAddMember(teamId: ID!, memberId: ID!): TeamAddMemberPayload!
  teamRemoveMember(teamId: ID!, memberId: ID!): TeamRemoveMemberPayload!
  teamAssignRole(teamId: ID!, memberId: ID!, role: TeamRole!): TeamAssignRolePayload!
  trustedDocumentsSubmit(
    accountSlug: String
    graphSlug: String
    projectSlug: String
    branchSlug: String!
    clientName: String!
    documents: [TrustedDocumentInput!]!
  ): TrustedDocumentsSubmitPayload!
  userUpdate(input: UserUpdateInput!): UserUpdatePayload!
  """
  Delete the user.
  """
  userDelete: UserDeletePayload!
}

type NameSizeCheckError {
  maxLength: Int!
  message: String!
  query: Query!
}

interface Node {
  id: ID!
}

type NotAllowedError {
  query: Query!
}

type NotAllowedToCancelInvitesError {
  query: Query!
}

type NotAllowedToDeleteOrganizationError {
  query: Query!
}

type NotAllowedToSendInvitesError {
  query: Query!
}

type NotAllowedToSlugUpdateError {
  query: Query!
}

type NotAllowedToUpdateOrganizationError {
  query: Query!
}

type OldAccessTokenError {
  query: Query!
}

type Operation implements Node {
  name: String
  type: OperationType!
  normalizedQuery: String!
  id: ID!
}

type OperationCheckError {
  title: String!
  message: String!
  severity: SchemaCheckErrorSeverity!
}

scalar OperationNormalizedQueryHash

enum OperationType {
  QUERY
  MUTATION
  SUBSCRIPTION
}

type Organization implements Account & Node {
  id: ID!
  slug: String!
  name: String!
  createdAt: DateTime!
  status: AccountStatus!
  plan: GrafbasePlan!
  samlDomain: String
  graphs(after: String, before: String, first: Int, last: Int): GraphConnection!
  integrations: [AccountIntegration!]! @deprecated(reason: "to be removed soon")
  invites(after: String, before: String, first: Int, last: Int): InviteConnection!
  members(after: String, before: String, first: Int, last: Int): MemberConnection!
  graphsCountStatus: ResourceStatus!
  slackIntegration: SlackIntegration
  """
  The url for the UI button to install the Grafbase slack app. It is
  important to use this link and keep it private, since it contains the signed
  account id of the authenticated user.
  """
  addToSlackLink: String!
  resourcesUsageDashboard(filter: AccountResourcesUsageDashboardFilter): AccountResourcesUsageDashboardPayload!
  accessTokens(after: String, before: String, first: Int, last: Int): AccessTokenConnection!
  resources: AccountResources! @deprecated(reason: "Not relevant for organizations")
  teams(after: String, first: Int): TeamConnection!
  trialExpiresAt: DateTime
}

type OrganizationConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [OrganizationEdge!]!
  """
  A list of nodes.
  """
  nodes: [Organization!]!
}

input OrganizationCreateInput {
  slug: String!
  name: String!
  email: String
}

union OrganizationCreatePayload =
  | OrganizationCreateSuccess
  | SlugError
  | SlugSizeCheckError
  | NameSizeCheckError
  | ReservedSlugsCheckError
  | TrialPlanUnavailableError
  | SlugAlreadyExistsError

type OrganizationCreateSuccess {
  organization: Organization!
  member: Member!
  query: Query!
}

input OrganizationDeleteInput {
  id: ID!
}

union OrganizationDeletePayload =
  | OrganizationDeleteSuccess
  | OrganizationDoesNotExistError
  | NotAllowedToDeleteOrganizationError

type OrganizationDeleteSuccess {
  deletedId: ID!
  query: Query!
}

type OrganizationDoesNotExistError {
  query: Query!
}

"""
An edge in a connection.
"""
type OrganizationEdge {
  """
  The item at the end of the edge
  """
  node: Organization!
  """
  A cursor for use in pagination
  """
  cursor: String!
}

type OrganizationOwnershipNotTransferredError {
  query: Query!
}

input OrganizationSlugUpdateInput {
  id: ID!
  slug: String!
}

union OrganizationSlugUpdatePayload =
  | OrganizationSlugUpdateSuccess
  | SlugError
  | SlugSizeCheckError
  | ReservedSlugsCheckError
  | SlugAlreadyExistsError
  | OrganizationDoesNotExistError
  | NotAllowedToSlugUpdateError

type OrganizationSlugUpdateSuccess {
  organization: Organization!
  query: Query!
}

input OrganizationUpdateInput {
  id: ID!
  name: String
}

union OrganizationUpdatePayload =
  | OrganizationUpdateSuccess
  | OrganizationDoesNotExistError
  | NameSizeCheckError
  | NotAllowedToUpdateOrganizationError

type OrganizationUpdateSuccess {
  organization: Organization!
  query: Query!
}

"""
Information about pagination in a connection
"""
type PageInfo {
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: String
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: String
}

type PersonalAccount implements Account {
  id: ID!
  slug: String!
  name: String!
  createdAt: DateTime!
  status: AccountStatus!
  plan: GrafbasePlan!
  graphs(after: String, before: String, first: Int, last: Int): GraphConnection!
  graphsCountStatus: ResourceStatus!
  resourcesUsageDashboard(filter: AccountResourcesUsageDashboardFilter): AccountResourcesUsageDashboardPayload!
  resources: AccountResources! @deprecated(reason: "use graphs_count_status")
  accessTokens(after: String, before: String, first: Int, last: Int): AccessTokenConnection!
}

union PersonalAccountDeletePayload = PersonalAccountDeleteSuccess | OrganizationOwnershipNotTransferredError

type PersonalAccountDeleteSuccess {
  deletedId: ID!
  query: Query!
}

input PersonalAccountSlugUpdateInput {
  slug: String!
}

union PersonalAccountSlugUpdatePayload =
  | PersonalAccountSlugUpdateSuccess
  | SlugError
  | SlugSizeCheckError
  | ReservedSlugsCheckError
  | SlugAlreadyExistsError

type PersonalAccountSlugUpdateSuccess {
  query: Query!
}

input PersonalAccountUpdateInput {
  name: String!
}

union PersonalAccountUpdatePayload = PersonalAccountUpdateSuccess | NameSizeCheckError

type PersonalAccountUpdateSuccess {
  query: Query!
}

type PreviousRequestAnalytcs {
  timeSeries: RequestMetricsTimeSeries!
  metrics: RequestMetrics!
}

type ProjectBranchDoesNotExistError {
  query: Query!
}

type ProjectDoesNotExistError {
  query: Query!
}

type ProjectDopplerIntegration {
  projectName: String!
  configName: String!
  automatedRedeploy: Boolean!
}

type ProjectNotFederatedError {
  query: Query!
}

type ProjectNotManagedError {
  query: Query!
}

type ProjectNotStandaloneError {
  query: Query!
}

type ProjectScopeLimitExceededError {
  query: Query!
}

type PublishForbidden {
  query: Query!
}

input PublishInput {
  accountSlug: String!
  graphSlug: String
  projectSlug: String
  branch: String
  subgraph: String!
  url: String!
  schema: String!
  message: String
}

union PublishPayload =
  | PublishSuccess
  | ProjectDoesNotExistError
  | GraphDoesNotExistError
  | FederatedGraphCompositionError
  | SchemaRegistryBranchDoesNotExistError
  | PublishForbidden

type PublishSuccess {
  query: Query!
}

type Query {
  accessTokens(after: String, before: String, first: Int, last: Int): AccessTokenConnection!
  accountBySlug(
    """
    slug of the account
    """
    slug: String!
  ): Account
  accountCreationValidate(input: AccountCreationValidateInput!): AccountCreationValidatePayload!
  """
  Get branch by account slug, graph slug and the name of the branch.
  """
  branch(
    """
    slug of the account
    """
    accountSlug: String
    """
    slug of the graph
    """
    graphSlug: String
    """
    slug of the project
    """
    projectSlug: String
    """
    name of the branch
    """
    name: String
  ): Branch
  """
  Get deployment by ID.
  """
  deployment(
    """
    ID of the deployment
    """
    id: ID!
  ): Deployment
  invite(id: ID!): Invite
  """
  Get a graph by account slug and slug of the graph itself.
  """
  graphByAccountSlug(
    """
    slug of the account
    """
    accountSlug: String!
    """
    slug of the graph
    """
    graphSlug: String!
  ): Graph
  schemaCheck(id: ID!): SchemaCheck
  schemaProposal(id: ID!): SchemaProposal
  """
  Get subgraph.
  """
  subgraph(
    """
    account slug
    """
    accountSlug: String!
    """
    project slug
    """
    projectSlug: String
    """
    graph slug
    """
    graphSlug: String
    """
    name of the branch
    """
    branch: String
    """
    name of the subgraph
    """
    subgraphName: String!
  ): Subgraph
  schemaVersion(id: ID!): SchemaVersion
  schemaVersions(
    """
    account slug
    """
    accountSlug: String!
    """
    project slug
    """
    projectSlug: String
    """
    graph slug
    """
    graphSlug: String
    """
    name of the branch
    """
    branch: String
    """
    name of the subgraph
    """
    subgraphName: String
    """
    return only versions with changes
    """
    populated: Boolean! = true
    after: String
    before: String
    first: Int
    last: Int
  ): SchemaVersionConnection!
  team(id: ID!): Team
  teamBySlug(organizationSlug: String!, slug: String!): Team
  """
  Give the actual connected user.
  """
  viewer: User
  node(id: ID!): Node
  integrations: [Integration!]!
  dopplerProjects(accountIntegrationId: ID!): [DopplerProject!]!
  dopplerConfigs(accountIntegrationId: ID!, dopplerProjectName: String!): [DopplerConfig!]!
  _service: _Service!
}

type Request implements Node {
  id: ID!
  trace: Trace!
  rootSpanId: ID!
  startedAt: DateTime!
  endedAt: DateTime!
  httpRequestMethod: String!
  httpStatusCode: Int!
  urlPath: String!
  userAgent: String!
  clientName: String!
  clientVersion: String!
  errorCount: Int!
  errorCountByCode: [ErrorCountByCode!]!
  operations: [RequestOperation!]!
}

type RequestAnalytics {
  timeSeries: RequestMetricsTimeSeries!
  metrics: RequestMetrics!
  periodStart: DateTime!
  periodEnd: DateTime!
  previousPeriodAnalytics: PreviousRequestAnalytcs
}

type RequestConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [RequestEdge!]!
  """
  A list of nodes.
  """
  nodes: [Request!]!
}

"""
An edge in a connection.
"""
type RequestEdge {
  """
  The item at the end of the edge
  """
  node: Request!
  """
  A cursor for use in pagination
  """
  cursor: String!
}

input RequestFilters {
  """
  Defaults to production branch
  """
  branchName: String
  """
  Use this if you really care about having a specific duration like 1 hour, 7 days, etc.
  """
  range: Duration
  """
  Use this if you *at least* the data between `from` and `to` to be provided. You may get
  more, but never less.
  """
  from: DateTime
  """
  To be used in conjunction with with either `range` or `from`.
  """
  to: DateTime!
  operationName: [String!]
  operationType: [OperationType!]
  clientName: [String!]
  """
  Only used if client name is specified.
  """
  clientVersion: [String!]
  traceId: [String!]
  duration: DurationFilter
  errorCode: [String!]
  httpStatusCode: [Int!]
}

type RequestLogEvent implements LogEvent {
  id: String!
  branch: String!
  environment: BranchEnvironment!
  deploymentId: ID!
  createdAt: DateTime!
  region: String!
  logLevel: LogLevel!
  url: String!
  httpMethod: String!
  httpStatus: Int!
  duration: Int!
  message: String!
}

type RequestMetrics {
  requestCount: Int!
  cacheableRequestCount: Int!
  cacheHitCount: Int!
  cacheMissCount: Int!
  cachePassCount: Int!
  error4XxCount: Int!
  error5XxCount: Int!
  errorGraphqlCount: Int!
  latencyMsP95: Int
  latencyMsP99: Int
}

type RequestMetricsTimeSeries {
  data: [RequestMetricsTimeSeriesDataPoint!]!
  aggregationStep: Duration!
}

type RequestMetricsTimeSeriesDataPoint {
  dateTime: DateTime!
  requestCount: Int!
  cacheableRequestCount: Int!
  cacheHitCount: Int!
  cacheMissCount: Int!
  cachePassCount: Int!
  error4XxCount: Int!
  error5XxCount: Int!
  errorGraphqlCount: Int!
  latencyMsP95: Int
  latencyMsP99: Int
}

type RequestMetricsTimeSeriesDataPointV2 {
  dateTime: DateTime!
  count: Int!
  cacheHitCount: Int!
  cacheMissCount: Int!
  cachePassCount: Int!
  error4XxCount: Int!
  error5XxCount: Int!
  errorGraphqlCount: Int!
  latencyMsPercentiles: [Int!]!
}

type RequestMetricsTimeSeriesV2 {
  overall: RequestMetricsV2!
  points: [RequestMetricsTimeSeriesDataPointV2!]!
  previousPeriod: RequestMetricsTimeSeriesV2
}

type RequestMetricsV2 {
  count: Int!
  cacheHitCount: Int!
  cacheMissCount: Int!
  cachePassCount: Int!
  error4XxCount: Int!
  error5XxCount: Int!
  errorGraphqlCount: Int!
  latencyMsPercentiles: [Int!]!
}

type RequestOperation {
  name: String!
  type: OperationType!
}

type ReservedSlugsCheckError {
  message: String!
  query: Query!
}

type ResourceStatus {
  unit: UnitType!
  used: Int!
  limit: Int
  remaining: Int
  percentage: Float
}

"""
An occurrence of a trusted document that was submitted again (same id), but with a different document text. This is an error.
"""
type ReusedId {
  """
  The document id
  """
  documentId: String!
  """
  The existing document body
  """
  existingDocumentText: String!
  """
  The different, newly submitted document body
  """
  newDocumentText: String!
}

"""
Trusted documents that were uploaded again (same id), but with a different document body. This is an error.
"""
type ReusedIds {
  reused: [ReusedId!]!
}

type ReviewerDoesNotExistError {
  query: Query!
}

enum SchemaChangeType {
  SCHEMA_DEFINITION_ADDED
  SCHEMA_DEFINITION_REMOVED
  SCHEMA_EXTENSION_ADDED
  SCHEMA_EXTENSION_REMOVED
  FIELD_ARGUMENT_DEFAULT_ADDED
  FIELD_ARGUMENT_DEFAULT_REMOVED
  FIELD_ARGUMENT_DESCRIPTION_CHANGED
  FIELD_ARGUMENT_DEFAULT_CHANGED
  FIELD_ARGUMENT_TYPE_CHANGED
  DIRECTIVE_REMOVED
  DIRECTIVE_ADDED
  DIRECTIVE_DESCRIPTION_CHANGED
  DIRECTIVE_LOCATION_ADDED
  DIRECTIVE_LOCATION_REMOVED
  DIRECTIVE_ARGUMENT_ADDED
  DIRECTIVE_ARGUMENT_REMOVED
  DIRECTIVE_ARGUMENT_DESCRIPTION_CHANGED
  DIRECTIVE_ARGUMENT_DEFAULT_VALUE_CHANGED
  DIRECTIVE_ARGUMENT_TYPE_CHANGED
  ENUM_ADDED
  ENUM_REMOVED
  ENUM_VALUE_REMOVED
  ENUM_VALUE_ADDED
  ENUM_VALUE_DESCRIPTION_CHANGED
  ENUM_VALUE_DEPRECATION_REASON_CHANGED
  ENUM_VALUE_DEPRECATION_REASON_ADDED
  ENUM_VALUE_DEPRECATION_REASON_REMOVED
  FIELD_REMOVED
  FIELD_ADDED
  FIELD_DESCRIPTION_CHANGED
  FIELD_DESCRIPTION_ADDED
  FIELD_DESCRIPTION_REMOVED
  FIELD_DEPRECATION_ADDED
  FIELD_DEPRECATION_REMOVED
  FIELD_DEPRECATION_REASON_CHANGED
  FIELD_DEPRECATION_REASON_ADDED
  FIELD_DEPRECATION_REASON_REMOVED
  FIELD_TYPE_CHANGED
  FIELD_ARGUMENT_ADDED
  FIELD_ARGUMENT_REMOVED
  INPUT_OBJECT_REMOVED
  INPUT_OBJECT_ADDED
  INPUT_FIELD_REMOVED
  INPUT_FIELD_ADDED
  INPUT_FIELD_DESCRIPTION_ADDED
  INPUT_FIELD_DESCRIPTION_REMOVED
  INPUT_FIELD_DESCRIPTION_CHANGED
  INPUT_FIELD_DEFAULT_VALUE_CHANGED
  INPUT_FIELD_TYPE_CHANGED
  OBJECT_TYPE_INTERFACE_ADDED
  OBJECT_TYPE_INTERFACE_REMOVED
  SCHEMA_QUERY_TYPE_CHANGED
  SCHEMA_MUTATION_TYPE_CHANGED
  SCHEMA_SUBSCRIPTION_TYPE_CHANGED
  TYPE_REMOVED
  TYPE_ADDED
  TYPE_KIND_CHANGED
  TYPE_DESCRIPTION_CHANGED
  TYPE_DESCRIPTION_REMOVED
  TYPE_DESCRIPTION_ADDED
  UNION_ADDED
  UNION_REMOVED
  UNION_MEMBER_REMOVED
  UNION_MEMBER_ADDED
  INTERFACE_ADDED
  INTERFACE_REMOVED
  INTERFACE_IMPLEMENTATION_ADDED
  INTERFACE_IMPLEMENTATION_REMOVED
  SCALAR_ADDED
  SCALAR_REMOVED
}

type SchemaCheck {
  id: ID!
  schema: String!
  subgraphName: String
  publishedSchemaVersion: ID @deprecated(reason: "This was never populated with relevant data")
  errorCount: Int!
  validationCheckErrors: [ValidationCheckError!]!
  compositionCheckErrors: [CompositionCheckError!]!
  operationCheckErrors: [OperationCheckError!]!
  lintCheckErrors: [LintCheckError!]!
  createdAt: DateTime!
  gitCommit: SchemaCheckGitCommit
}

type SchemaCheckConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [SchemaCheckEdge!]!
  """
  A list of nodes.
  """
  nodes: [SchemaCheck!]!
}

input SchemaCheckCreateInput {
  accountSlug: String!
  projectSlug: String
  graphSlug: String
  branch: String
  subgraphName: String
  schema: String!
  gitCommit: SchemaCheckGitCommitInput
}

"""
An edge in a connection.
"""
type SchemaCheckEdge {
  """
  The item at the end of the edge
  """
  node: SchemaCheck!
  """
  A cursor for use in pagination
  """
  cursor: String!
}

enum SchemaCheckErrorSeverity {
  ERROR
  WARNING
}

type SchemaCheckGitCommit {
  branch: String!
  commitSha: String!
  commitUrl: String
  message: String!
  authorName: String!
  authorAvatarUrl: String
}

input SchemaCheckGitCommitInput {
  branch: String!
  commitSha: String!
  commitUrl: String
  message: String!
  authorName: String!
  authorAvatarUrl: String
}

union SchemaCheckPayload =
  | SchemaCheck
  | GraphBranchDoesNotExistError
  | ProjectBranchDoesNotExistError
  | GraphDoesNotExistError
  | ProjectDoesNotExistError
  | SubgraphNameProvidedOnSingleProjectError
  | SubgraphNameProvidedOnStandaloneProjectError
  | SubgraphNameProvidedOnStandaloneGraphError
  | SubgraphNameMissingOnFederatedProjectError
  | SubgraphNameMissingOnFederatedGraphError

type SchemaProposal {
  id: ID!
  title: String!
  author: User
  description: String
  status: SchemaProposalStatus!
  createdAt: DateTime!
  """
  The whole activity feed.
  """
  activityFeed: [SchemaProposalActivityFeedItem!]!
  """
  The revision number of the proposal, i.e. how many times edits were applied to the proposal's subgraphs.
  """
  revision: Int!
  subgraph(subgraphName: String!): SchemaProposalSubgraph
  subgraphs: [SchemaProposalSubgraph!]!
  comments: [SchemaProposalComment!]!
  """
  Is the currently logged in user a reviewer of this proposal? That is to say, eitheir they are configured as a reviewer, or
  """
  viewerIsReviewer: Boolean!
}

interface SchemaProposalActivityFeedItem {
  id: ID!
  createdAt: DateTime!
}

type SchemaProposalApproval implements SchemaProposalActivityFeedItem {
  id: ID!
  author: User
  message: String
  createdAt: DateTime!
}

input SchemaProposalApproveInput {
  id: ID!
  message: String
}

union SchemaProposalApprovePayload = SchemaProposalApproveSuccess

type SchemaProposalApproveSuccess {
  query: Query!
}

interface SchemaProposalComment {
  id: ID!
  text: String!
  createdAt: DateTime!
  author: User
}

type SchemaProposalCommentOnLine implements SchemaProposalActivityFeedItem & SchemaProposalComment {
  id: ID!
  """
  Is this comment thread resolved?
  """
  resolved: Boolean!
  """
  The user who marked the thread as resolved.
  """
  resolvedBy: User
  """
  The content of the comment.
  """
  text: String!
  createdAt: DateTime!
  """
  Who wrote the comment. Will be null in case the user was deleted.
  """
  author: User
  """
  All the replies in chronological order, from oldest to newest.
  """
  replies: [SchemaProposalReply!]!
  """
  Which subgraph the comment applies to.
  """
  subgraphName: String!
  """
  The logical path in the schema where the comment is located. This is only exposed for debugging, prefer using the `line` field.
  """
  path: String!
  """
  Which line the comment applies to in the subgraph SDL. This may be `null` if the comment was on an item that is no longer part of the current subgraph schema.

  The line is 1-indexes
  """
  line: Int
  """
  The section of the subgraph SDL where the comment is located.
  """
  context(
    """
    How many lines around the commented line to include. Fewer lines can be returned if the context reaches the start or the end of the schema.
    """
    contextLines: Int!
  ): String
}

type SchemaProposalCommentOnProposal implements SchemaProposalActivityFeedItem & SchemaProposalComment {
  id: ID!
  text: String!
  createdAt: DateTime!
  """
  Who wrote the comment. Will be null in case the user was deleted.
  """
  author: User
  replies: [SchemaProposalReply!]!
}

type SchemaProposalCommentOnSdl implements SchemaProposalActivityFeedItem & SchemaProposalComment {
  id: ID!
  """
  Is this comment thread resolved?
  """
  resolved: Boolean!
  """
  The user who marked the thread as resolved.
  """
  resolvedBy: User
  text: String!
  createdAt: DateTime!
  author: User
  replies: [SchemaProposalReply!]!
}

union SchemaProposalCommentReplyPayload = SchemaProposalCommentReplySuccess

type SchemaProposalCommentReplySuccess {
  query: Query!
}

input SchemaProposalCommentThreadCreateInput {
  """
  The parent schema proposal.
  """
  schemaProposalId: ID!
  """
  Where the comment is located.
  """
  location: SchemaProposalCommentThreadLocation!
  """
  The revision / version number of the proposal, obtained from SchemaProposal.revision. Must be provided if and only if location is Line.

  This argument is necessary to avoid cases where the schema has been updated between the time it was retried and the time the comment is posted. In these cases, if we use the latest subgraph schema, the line numbers may have changed and the comment would end up in the wrong place.
  """
  proposalRevision: Int
  """
  Must be provided if and only if location is Line.
  """
  subgraphName: String
  """
  Must be provided if and only if location is Line.
  """
  line: Int
  """
  The content of the comment.
  """
  text: String!
}

union SchemaProposalCommentThreadCreatePayload =
  | SchemaProposalCommentThreadCreateSuccess
  | SchemaProposalDoesNotExistError

type SchemaProposalCommentThreadCreateSuccess {
  query: Query!
}

enum SchemaProposalCommentThreadLocation {
  """
  On a specific line, in a specific subgraph
  """
  LINE
  """
  On the schema proposal SDL.
  """
  SDL
  """
  On the schema proposal itself.
  """
  PROPOSAL
}

union SchemaProposalCommentThreadResolvePayload = SchemaProposalCommentThreadResolveSuccess

type SchemaProposalCommentThreadResolveSuccess {
  query: Query!
  affectedRows: Int!
}

union SchemaProposalCommentThreadUnresolvePayload = SchemaProposalCommentThreadUnresolveSuccess

type SchemaProposalCommentThreadUnresolveSuccess {
  query: Query!
  affectedRows: Int!
}

type SchemaProposalConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [SchemaProposalEdge!]!
  """
  A list of nodes.
  """
  nodes: [SchemaProposal!]!
}

input SchemaProposalCreateInput {
  title: String!
  branchId: ID!
  description: String
}

union SchemaProposalCreatePayload = SchemaProposalCreateSuccess

type SchemaProposalCreateSuccess {
  schemaProposal: SchemaProposal!
  query: Query!
}

union SchemaProposalDeletePayload = SchemaProposalDeleteSuccess | SchemaProposalDoesNotExistError

type SchemaProposalDeleteSuccess {
  query: Query!
}

type SchemaProposalDoesNotExistError {
  query: Query!
}

"""
An edge in a connection.
"""
type SchemaProposalEdge {
  """
  The item at the end of the edge
  """
  node: SchemaProposal!
  """
  A cursor for use in pagination
  """
  cursor: String!
}

input SchemaProposalEditInput {
  schemaProposalId: ID!
  subgraphs: [SchemaProposalEditSubgraph!]!
  description: String
}

type SchemaProposalEditParserError {
  subgraphName: String!
  error: String!
  spanStart: Int!
  spanEnd: Int!
}

type SchemaProposalEditParserErrors {
  errors: [SchemaProposalEditParserError!]!
}

union SchemaProposalEditPayload =
  | SchemaProposalEditSuccess
  | SchemaProposalDoesNotExistError
  | SchemaProposalEditParserErrors

input SchemaProposalEditSubgraph {
  name: String!
  schema: String
}

type SchemaProposalEditSuccess {
  query: Query!
}

input SchemaProposalFilter {
  status: SchemaProposalStatus
}

input SchemaProposalRejectInput {
  id: ID!
  message: String
}

union SchemaProposalRejectPayload = SchemaProposalRejectSuccess

type SchemaProposalRejectSuccess {
  query: Query!
}

type SchemaProposalRejection implements SchemaProposalActivityFeedItem {
  id: ID!
  author: User
  message: String
  createdAt: DateTime!
}

type SchemaProposalReply implements SchemaProposalComment {
  id: ID!
  text: String!
  """
  Who wrote the comment. Will be null in case the user was deleted.
  """
  author: User
  createdAt: DateTime!
}

input SchemaProposalRequestReviewInput {
  id: ID!
}

union SchemaProposalRequestReviewPayload = SchemaProposalRequestReviewSuccess

type SchemaProposalRequestReviewSuccess {
  query: Query!
}

type SchemaProposalReviewRequest implements SchemaProposalActivityFeedItem {
  id: ID!
  requestedBy: ID!
  requestFor: UserOrTeam!
  createdAt: DateTime!
}

input SchemaProposalReviewRequestCreateInput {
  schemaProposalId: ID!
  """
  Must be either a team id or a user id.
  """
  reviewerId: ID!
}

union SchemaProposalReviewRequestCreatePayload =
  | SchemaProposalReviewRequestCreateSuccess
  | SchemaProposalDoesNotExistError

type SchemaProposalReviewRequestCreateSuccess {
  query: Query!
}

enum SchemaProposalStatus {
  APPROVED
  DRAFT
  IMPLEMENTED
  REJECTED
  IN_REVIEW
}

type SchemaProposalSubgraph {
  sdl: String
  status: SchemaProposalSubgraphStatus!
  name: String!
  diffSnippets: [DiffSnippet!]!
  comments: [SchemaProposalComment!]!
}

enum SchemaProposalSubgraphStatus {
  CREATED
  EDITED
  DELETED
  UNCHANGED
}

type SchemaProposalsConfiguration {
  enforceChecks: Boolean!
  requireApprovalFromSubgraphOwners: Boolean!
  keepApprovalsOnEdit: Boolean!
  configuredReviewers: [SchemaProposalsConfiguredReviewers!]!
}

input SchemaProposalsConfigurationUpdateInput {
  enforceChecks: Boolean
  requireApprovalFromSubgraphOwners: Boolean
  keepApprovalsOnEdit: Boolean
}

input SchemaProposalsConfiguredReviewerAddInput {
  branchId: ID!
  """
  Either a UserId or a TeamId
  """
  reviewerId: ID!
}

union SchemaProposalsConfiguredReviewerAddPayload =
  | SchemaProposalsConfiguredReviewerAddSuccess
  | BranchDoesNotExistError
  | UserDoesNotExistError
  | TeamDoesNotExistError
  | AlreadyExistsError

type SchemaProposalsConfiguredReviewerAddSuccess {
  query: Query!
  reviewer: SchemaProposalsConfiguredReviewers!
}

input SchemaProposalsConfiguredReviewerRemoveInput {
  branchId: ID!
  """
  Either a SchemaProposalUserReviewerId or a SchemaProposalTeamReviewerId
  """
  reviewerId: ID!
}

union SchemaProposalsConfiguredReviewerRemovePayload =
  | SchemaProposalsConfiguredReviewerRemoveSuccess
  | BranchDoesNotExistError
  | ReviewerDoesNotExistError

type SchemaProposalsConfiguredReviewerRemoveSuccess {
  query: Query!
}

type SchemaProposalsConfiguredReviewerTeam {
  id: ID!
  team: Team!
}

type SchemaProposalsConfiguredReviewerUser {
  id: ID!
  user: User!
}

"""
A (required) schema proposal reviewer in the branch configuration.
"""
union SchemaProposalsConfiguredReviewers = SchemaProposalsConfiguredReviewerUser | SchemaProposalsConfiguredReviewerTeam

type SchemaRegistryBranchDoesNotExistError {
  query: Query!
}

type SchemaVersion {
  id: ID!
  schema: String!
  delta: SchemaVersionDelta!
  changes(after: String, before: String, first: Int, last: Int): SchemaVersionChangeConnection!
  createdAt: DateTime!
  message: String
}

type SchemaVersionChange {
  path: String
  type: SchemaChangeType!
  message: String!
}

type SchemaVersionChangeConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [SchemaVersionChangeEdge!]!
  """
  A list of nodes.
  """
  nodes: [SchemaVersionChange!]!
}

"""
An edge in a connection.
"""
type SchemaVersionChangeEdge {
  """
  The item at the end of the edge
  """
  node: SchemaVersionChange!
  """
  A cursor for use in pagination
  """
  cursor: String!
}

type SchemaVersionConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [SchemaVersionEdge!]!
  """
  A list of nodes.
  """
  nodes: [SchemaVersion!]!
}

type SchemaVersionDelta {
  """
  Additions.
  """
  added: Int!
  """
  Removals.
  """
  removed: Int!
  """
  Modifications.
  """
  modified: Int!
}

"""
An edge in a connection.
"""
type SchemaVersionEdge {
  """
  The item at the end of the edge
  """
  node: SchemaVersion!
  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
A Slack channel returned from the Slack API.
"""
type SlackChannel {
  id: String!
  name: String!
}

type SlackIntegration {
  availableChannels: [SlackChannel!]!
  notifications: [SlackNotification!]!
}

input SlackIntegrationCreateInput {
  tokenId: String!
  """
  The graph_id field is deprecated. Pass branch_id instead.
  """
  graphId: String
  branchId: ID
  channelId: String!
  channelName: String!
}

type SlackNotification {
  id: String!
  graphId: String! @deprecated(reason: "Graphs are being removed. Please use SlackNotification.branch_id instead")
  branchId: String!
  channelName: String!
}

union SlackNotificationCreatePayload = SlackNotification | ProjectDoesNotExistError

union SlackNotificationDeletePayload = Query

type SlugAlreadyExistsError {
  query: Query!
}

type SlugError {
  message: String!
  actual: String!
  expected: String!
  query: Query!
}

type SlugInvalidError {
  query: Query!
}

type SlugSizeCheckError {
  maxLength: Int!
  message: String!
  query: Query!
}

type SlugTooLongError {
  maxLength: Int!
  query: Query!
}

type StandaloneGraphsNoLongerSupportedError {
  query: Query!
}

type Subgraph {
  name: String!
  url: String!
  schema: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  owners: [Team!]!
}

union SubgraphAddOwnerPayload = SubgraphAddOwnerSuccess

type SubgraphAddOwnerSuccess {
  query: Query!
}

type SubgraphNameMissingOnFederatedGraphError {
  query: Query!
}

type SubgraphNameMissingOnFederatedProjectError {
  query: Query!
}

type SubgraphNameProvidedOnSingleProjectError {
  query: Query! @deprecated(reason: "Type renamed to SubgraphNameProvidedOnStandaloneProjectError")
}

type SubgraphNameProvidedOnStandaloneGraphError {
  query: Query!
}

type SubgraphNameProvidedOnStandaloneProjectError {
  query: Query!
}

type SubgraphNotFoundError {
  query: Query!
}

union SubgraphRemoveOwnerPayload = SubgraphRemoveOwnerSuccess

type SubgraphRemoveOwnerSuccess {
  query: Query!
}

type Team implements Node {
  id: ID!
  name: String!
  slug: String!
  """
  The users that are part of the team
  """
  members(after: String, first: Int): UserConnection!
  parentTeamId: ID
  """
  The team this team is member of, if any.
  """
  parent: Team
  """
  The teams that are part of the team
  """
  subteams(after: String, first: Int): TeamConnection!
  query: Query!
}

union TeamAddMemberPayload = TeamAddMemberSuccess | TeamDoesNotExistError

type TeamAddMemberSuccess {
  query: Query!
}

union TeamAssignRolePayload = TeamAssignRoleSuccess | TeamDoesNotExistError

type TeamAssignRoleSuccess {
  query: Query!
}

type TeamConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [TeamEdge!]!
  """
  A list of nodes.
  """
  nodes: [Team!]!
}

union TeamCreatePayload = Team | OrganizationDoesNotExistError | TeamNameAlreadyTakenError

union TeamDeletePayload = TeamDeleteSuccess | TeamDoesNotExistError

type TeamDeleteSuccess {
  query: Query!
}

type TeamDoesNotExistError {
  query: Query!
}

"""
An edge in a connection.
"""
type TeamEdge {
  """
  The item at the end of the edge
  """
  node: Team!
  """
  A cursor for use in pagination
  """
  cursor: String!
}

type TeamNameAlreadyTakenError {
  query: Query!
}

union TeamRemoveMemberPayload = TeamRemoveMemberSuccess | TeamDoesNotExistError

type TeamRemoveMemberSuccess {
  query: Query!
}

enum TeamRole {
  """
  __Team__ admin
  """
  ADMIN
  """
  Regular non-admin member.
  """
  MEMBER
}

enum TimeAggregationGranularity {
  DAILY
  WEEKLY
  MONTHLY
}

type TimeSeries {
  unit: UnitType!
  data: [TimeSeriesDataPoint!]!
  statistics: TimeSeriesStatistics!
}

type TimeSeriesDataPoint {
  datetime: DateTime!
  value: Int!
}

type TimeSeriesStatistics {
  sum: Int!
}

type TokenDoesNotExistError {
  query: Query!
}

type TokenLimitExceededError {
  query: Query!
}

type TopClientByNameAndVersionOrderedByHighestCount {
  name: String!
  version: String!
  count: Int!
}

type TopClientByNameAndVersionOrderedByHighestErrorRatio {
  name: String!
  version: String!
  count: Int!
  errorCount: Int!
}

type TopClientByNameAndVersionOrderedByHighestLatency {
  name: String!
  version: String!
  latencyMs: Int!
}

type TopClientByNameOrderedByHighestCount {
  name: String!
  count: Int!
}

type TopClientByNameOrderedByHighestErrorRatio {
  name: String!
  count: Int!
  errorCount: Int!
}

type TopClientByNameOrderedByHighestLatency {
  name: String!
  latencyMs: Int!
}

type TopClients {
  byName: TopClientsByName!
  byNameAndVersion: TopClientsByNameAndVersion!
}

type TopClientsByName {
  orderedByHighestLatency: [TopClientByNameOrderedByHighestLatency!]!
  orderedByHighestCount: [TopClientByNameOrderedByHighestCount!]!
  orderedByHighestErrorRatio: [TopClientByNameOrderedByHighestErrorRatio!]!
}

type TopClientsByNameAndVersion {
  orderedByHighestLatency: [TopClientByNameAndVersionOrderedByHighestLatency!]!
  orderedByHighestCount: [TopClientByNameAndVersionOrderedByHighestCount!]!
  orderedByHighestErrorRatio: [TopClientByNameAndVersionOrderedByHighestErrorRatio!]!
}

type TopClientsForField {
  byName: TopClientsForFieldByName!
  byNameAndVersion: TopClientsForFieldByNameAndVersion!
}

type TopClientsForFieldByName {
  orderedByHighestCount: [TopClientByNameOrderedByHighestCount!]!
}

type TopClientsForFieldByNameAndVersion {
  orderedByHighestCount: [TopClientByNameAndVersionOrderedByHighestCount!]!
}

type TopOperationByNameAndHashOrderedByHighestCount {
  name: String!
  normalizedQueryHash: OperationNormalizedQueryHash!
  count: Int!
}

type TopOperationByNameAndHashOrderedByHighestErrorRatio {
  name: String!
  normalizedQueryHash: OperationNormalizedQueryHash!
  count: Int!
  errorCount: Int!
}

type TopOperationByNameAndHashOrderedByHighestLatency {
  name: String!
  normalizedQueryHash: OperationNormalizedQueryHash!
  latencyMs: Int!
}

type TopOperationByNameOrderedByHighestCount {
  name: String!
  count: Int!
}

type TopOperationByNameOrderedByHighestErrorRatio {
  name: String!
  count: Int!
  errorCount: Int!
}

type TopOperationByNameOrderedByHighestLatency {
  name: String!
  latencyMs: Int!
}

type TopOperations {
  byName: TopOperationsByName!
  byNameAndHash: TopOperationsByNameAndHash!
}

type TopOperationsByName {
  orderedByHighestLatency: [TopOperationByNameOrderedByHighestLatency!]!
  orderedByHighestCount: [TopOperationByNameOrderedByHighestCount!]!
  orderedByHighestErrorRatio: [TopOperationByNameOrderedByHighestErrorRatio!]!
}

type TopOperationsByNameAndHash {
  orderedByHighestLatency: [TopOperationByNameAndHashOrderedByHighestLatency!]!
  orderedByHighestCount: [TopOperationByNameAndHashOrderedByHighestCount!]!
  orderedByHighestErrorRatio: [TopOperationByNameAndHashOrderedByHighestErrorRatio!]!
}

type Trace {
  id: ID!
  rootSpanId: ID!
  spans: [TraceSpan!]!
}

type TraceSpan {
  id: ID!
  parentId: ID
  name: String!
  startedAt: DateTime!
  endedAt: DateTime!
  statusCode: TraceSpanStatusCode
  """
  Attributes are key-value pairs that represent additional information about the span.
  It's always a map of strings to strings.
  """
  attributes: JSON!
}

enum TraceSpanStatusCode {
  OK
  ERROR
}

type TrialPlanUnavailableError {
  query: Query!
}

type TrustedDocument {
  documentId: String!
  documentText: String!
}

input TrustedDocumentInput {
  documentId: String!
  documentText: String!
}

union TrustedDocumentsSubmitPayload =
  | TrustedDocumentsSubmitSuccess
  | ReusedIds
  | GraphDoesNotExistError
  | ProjectDoesNotExistError
  | OldAccessTokenError

type TrustedDocumentsSubmitSuccess {
  count: Int!
  documents: [TrustedDocument!]!
}

enum UnitType {
  NO_UNIT
  MILLI_SECONDS
  BYTES
}

type User implements Node {
  id: ID!
  name: String!
  email: String!
  avatarUrl: String
  createdAt: DateTime!
  organizations(after: String, before: String, first: Int, last: Int): OrganizationConnection!
  organizationMemberships: [Member!]!
  canStartNewTrial: Boolean!
}

type UserConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [UserEdge!]!
  """
  A list of nodes.
  """
  nodes: [User!]!
  totalCount: Int!
}

union UserDeletePayload = UserDeleteSuccess | OrganizationOwnershipNotTransferredError

type UserDeleteSuccess {
  query: Query!
}

type UserDoesNotExistError {
  query: Query!
}

"""
An edge in a connection.
"""
type UserEdge {
  """
  The item at the end of the edge
  """
  node: User!
  role: TeamRole!
  """
  A cursor for use in pagination
  """
  cursor: String!
}

union UserOrTeam = User | Team

input UserUpdateInput {
  name: String!
}

union UserUpdatePayload = UserUpdateSuccess | NameSizeCheckError

type UserUpdateSuccess {
  query: Query!
}

type ValidationCheckError {
  title: String!
  message: String!
}

"""
The `_Any` scalar is used to pass representations of entities from external
services into the root `_entities` field for execution.
"""
scalar _Any

type _Service {
  sdl: String
}

directive @deprecated(
  reason: String = "No longer supported"
) on FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION | ENUM_VALUE
directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
directive @oneOf on INPUT_OBJECT
directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
directive @specifiedBy(url: String!) on SCALAR
schema {
  query: Query
  mutation: Mutation
}
