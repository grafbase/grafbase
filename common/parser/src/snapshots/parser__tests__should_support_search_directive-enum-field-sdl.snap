---
source: common/parser/src/tests.rs
expression: sdl
---
"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, is compliant with the date-time format outlined in section 5.6 of the RFC 3339
profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.

This scalar is a description of an exact instant on the timeline such as the instant that a user account was created.

# Input Coercion

When expected as an input type, only RFC 3339 compliant date-time strings are accepted. All other input values raise a query error indicating an incorrect type.

# Result Coercion

Where an RFC 3339 compliant date-time string has a time-zone other than UTC, it is shifted to UTC.
For example, the date-time string 2016-01-01T14:10:20+01:00 is shifted to 2016-01-01T13:10:20Z.
"""
scalar DateTime
input DateTimeSearchFilterInput {
	ALL: [DateTimeSearchFilterInput!]
	ANY: [DateTimeSearchFilterInput!]
	NONE: [DateTimeSearchFilterInput!]
	NOT: DateTimeSearchFilterInput
	eq: DateTime
	neq: DateTime
	gt: DateTime
	gte: DateTime
	lte: DateTime
	lt: DateTime
	in: [DateTime!]
	notIn: [DateTime!]
}
type Mutation {
	"""
	Create a Product
	"""
	productCreate(input: ProductCreateInput!): ProductCreatePayload
	"""
	Update a Product
	"""
	productUpdate(by: ProductByInput!, input: ProductUpdateInput!): ProductUpdatePayload
	"""
	Delete a Product by ID or unique field
	"""
	productDelete(by: ProductByInput!): ProductDeletePayload
}
enum OrderByDirection {
	ASC
	DESC
}
type PageInfo {
	hasPreviousPage: Boolean!
	hasNextPage: Boolean!
	startCursor: String
	endCursor: String
}
enum Pet {
	CAT
	DOG
}
input PetListSearchFilterInput {
	includes: PetSearchFilterInput
	includesNone: PetSearchFilterInput
	isEmpty: Boolean
}
input PetSearchFilterInput {
	eq: Pet
	neq: Pet
	in: [Pet!]
	notIn: [Pet!]
}
type Product {
	status: Status
	pet: Pet!
	pets: [Pet!]
	name: String
	"""
	Unique identifier
	"""
	id: ID!
	"""
	when the model was updated
	"""
	updatedAt: DateTime!
	"""
	when the model was created
	"""
	createdAt: DateTime!
}
input ProductByInput {
	id: ID
}
type ProductConnection {
	"""
	Information to aid in pagination
	"""
	pageInfo: PageInfo!
	edges: [ProductEdge]
}
"""
Input to create a Product
"""
input ProductCreateInput {
	status: Status
	pet: Pet!
	pets: [Pet!]
	name: String
}
type ProductCreatePayload {
	product: Product
}
type ProductDeletePayload {
	deletedId: ID!
}
type ProductEdge {
	node: Product!
	cursor: String!
}
input ProductOrderByInput {
	createdAt: OrderByDirection
}
type ProductSearchConnection {
	pageInfo: PageInfo!
	searchInfo: SearchInfo
	edges: [ProductSearchEdge!]!
}
type ProductSearchEdge {
	node: Product!
	cursor: String!
	score: Float!
}
input ProductSearchFilterInput {
	ALL: [ProductSearchFilterInput!]
	ANY: [ProductSearchFilterInput!]
	NONE: [ProductSearchFilterInput!]
	NOT: ProductSearchFilterInput
	createdAt: DateTimeSearchFilterInput
	name: StringOrNullSearchFilterInput
	pet: PetSearchFilterInput
	pets: PetListSearchFilterInput
	status: StatusOrNullSearchFilterInput
	updatedAt: DateTimeSearchFilterInput
}
"""
Input to update a Product
"""
input ProductUpdateInput {
	status: Status
	pet: Pet
	pets: [Pet!]
	name: String
}
type ProductUpdatePayload {
	product: Product
}
type Query {
	"""
	Query a single Product by an ID or a unique field
	"""
	product(by: ProductByInput!): Product
	"""
	Paginated query to fetch the whole list of `Product`.
	"""
	productCollection(after: String, before: String, first: Int, last: Int, orderBy: ProductOrderByInput): ProductConnection
	"""
	Search `Product`
	"""
	productSearch(query: String, fields: [String!], filter: ProductSearchFilterInput, first: Int, after: String, last: Int, before: String): ProductSearchConnection
}
type SearchInfo {
	totalHits: Int!
}
enum Status {
	ACTIVE
	INACTIVE
}
input StatusOrNullSearchFilterInput {
	eq: Status
	neq: Status
	in: [Status!]
	notIn: [Status!]
	isNull: Boolean
}
input StringOrNullSearchFilterInput {
	ALL: [StringOrNullSearchFilterInput!]
	ANY: [StringOrNullSearchFilterInput!]
	NONE: [StringOrNullSearchFilterInput!]
	NOT: StringOrNullSearchFilterInput
	eq: String
	neq: String
	gt: String
	gte: String
	lte: String
	lt: String
	in: [String!]
	notIn: [String!]
	isNull: Boolean
}
schema {
	query: Query
	mutation: Mutation
}

