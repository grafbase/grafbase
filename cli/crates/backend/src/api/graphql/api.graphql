type AccessToken implements Node {
  id: ID!
  name: String!
  accountId: ID
  createdAt: DateTime!
}

type AccessTokenConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [AccessTokenEdge!]!

  """
  A list of nodes.
  """
  nodes: [AccessToken!]!
}

input AccessTokenCreateInput {
  name: String!
  accountId: ID
  kind: AccessTokenKind! = USER
  projectScopes: [ID!]
}

union AccessTokenCreatePayload =
  | AccessTokenCreateSuccess
  | InvalidAccountError
  | TokenLimitExceededError
  | ProjectScopeLimitExceededError
  | CouldNotFindProjectsError

type AccessTokenCreateSuccess {
  token: AccessToken!
  jwt: String!
  query: Query!
}

input AccessTokenDeleteInput {
  id: ID!
}

union AccessTokenDeletePayload = AccessTokenDeleteSuccess | TokenDoesNotExistError

type AccessTokenDeleteSuccess {
  deletedId: ID!
  query: Query!
}

"""
An edge in a connection.
"""
type AccessTokenEdge {
  """
  The item at the end of the edge
  """
  node: AccessToken!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

enum AccessTokenKind {
  USER
  ACCOUNT
}

interface Account {
  id: ID!
  slug: String!
  name: String!
  plan: GrafbasePlan!
  createdAt: DateTime!
  status: AccountStatus!
  projects(after: String, before: String, first: Int, last: Int): ProjectConnection!
  projectsCountStatus: ResourceStatus!
  resources: AccountResources!
  usage(filter: AccountResourcesUsageDashboardFilter): DatabaseUsage!
  resourcesUsageDashboard(filter: AccountResourcesUsageDashboardFilter): AccountResourcesUsageDashboardPayload!
  accessTokens(after: String, before: String, first: Int, last: Int): AccessTokenConnection!
}

input AccountCreationValidateInput {
  slug: String!
}

type AccountCreationValidatePayload {
  slugAvailable: Boolean!
}

type AccountDoesNotExistError {
  query: Query!
}

type AccountIntegration {
  accountId: ID!
  createdAt: DateTime!
  enabled: Boolean!
  id: ID!
  integrationId: ID!
  attributes: AccountIntegrationAttributes!
  projects: [ProjectIntegration!]!
}

union AccountIntegrationAttributes = DatadogIntegration

input AccountIntegrationAttributesInput {
  datadog: DatadogIntegrationInput
}

input AccountIntegrationInput {
  enabled: Boolean!
  projects: [ID!]
  attributes: AccountIntegrationAttributesInput!
}

type AccountIntegrationMutationError {
  message: String!
  query: Query!
}

union AccountIntegrationMutationPayload = AccountIntegrationMutationSuccess | AccountIntegrationMutationError

type AccountIntegrationMutationSuccess {
  account: Account!
  query: Query!
}

type AccountResources {
  projects: ResourceStatus!
}

type AccountResourcesStatus {
  requestCount: ResourceStatus!
  dbReads: ResourceStatus!
  dbWrites: ResourceStatus!
  dbSize: ResourceStatus!
  buildDuration: ResourceStatus!
  udfRequestCount: ResourceStatus!
  udfExecUnits: ResourceStatus!
  execUnits: ResourceStatus!
}

type AccountResourcesUsage {
  requestCount: TimeSeries!
  dbReads: TimeSeries!
  dbWrites: TimeSeries!
  dbSize: TimeSeries!
  buildDuration: TimeSeries!
  udfExecUnits: TimeSeries!
  udfRequestCount: TimeSeries!
  granularity: TimeAggregationGranularity!
  execUnits: TimeSeries!
}

"""
'limit_cycle_choice' is exclusive with all other options. It's the only case
where we'll show account limit status (used/limit)
"""
input AccountResourcesUsageDashboardFilter {
  projectIds: [ID!]
  limitCycleChoice: LimitCycleChoice
  startDate: DateTime
  endDate: DateTime
}

type AccountResourcesUsageDashboardInvalidFilterCombinationError {
  message: String!
  query: Query!
}

union AccountResourcesUsageDashboardPayload =
  | AccountResourcesUsageDashboardSuccess
  | AccountResourcesUsageDashboardInvalidFilterCombinationError

type AccountResourcesUsageDashboardSuccess {
  periodStart: DateTime!
  periodEnd: DateTime!
  usage: AccountResourcesUsage!
  status: AccountResourcesStatus
}

type AccountStatus {
  isEnabled: Boolean!
  inArrearsCause: InArrearsCause
  hasExceededLimits: Boolean!
  isHobbyPlanEnforced: Boolean!
}

type AlreadyMemberError {
  query: Query!
}

type ArchiveFileSizeLimitExceededError {
  query: Query!
  limit: Int!
}

type Branch implements Node {
  id: ID!
  name: String!
  domains: [String!]!
  latestDeployment: Deployment
  activeDeployment: Deployment
  deployments(after: String, before: String, first: Int, last: Int): DeploymentConnection!
  project: Project!
  environment: BranchEnvironment!
  schema: String
  federatedSchema: String
  operationChecksEnabled: Boolean!
  subgraphs: [Subgraph!]!
}

type BranchConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [BranchEdge!]!

  """
  A list of nodes.
  """
  nodes: [Branch!]!
}

union BranchDeletePayload = Query | BranchDoesNotExistError

type BranchDoesNotExistError {
  query: Query!
}

"""
An edge in a connection.
"""
type BranchEdge {
  """
  The item at the end of the edge
  """
  node: Branch!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

enum BranchEnvironment {
  PREVIEW
  PRODUCTION
}

union BranchMetricsPayload = BranchMetricsSuccess | ProjectDoesNotExistError

type BranchMetricsSuccess {
  latency: Distribution!
  request: Distribution!
}

type BranchNotDeployedError {
  query: Query!
}

input BranchUpdateInput {
  accountSlug: String!
  projectSlug: String!
  branchSlug: String!
  trustedDocumentsEnforce: Boolean
  trustedDocumentsBypassHeaderName: String
  trustedDocumentsBypassHeaderValue: String
  operationChecksEnabled: Boolean
}

union BranchUpdatePayload = Query | ProjectDoesNotExistError

type CannotBeRenamedError {
  query: Query!
}

type CannotUseInvitationsWithSSO {
  query: Query!
}

type CompositionCheckError {
  title: String!
  message: String!
}

type CouldNotFindProjectsError {
  unknownProjectIds: [ID!]!
}

type CurrentPlanLimitReachedError {
  max: Int!
  query: Query!
}

type CustomDomain {
  hostnameVerificationStatus: CustomDomainStatus!
  hostnameVerificationTxtName: String
  hostnameVerificationTxtValue: String
  name: String!
  sslVerificationCnameName: String
  sslVerificationCnameValue: String
  sslVerificationStatus: CustomDomainStatus!
  branch: String!
}

type CustomDomainAlreadyExistsError {
  query: Query!
}

input CustomDomainCreateInput {
  projectId: ID!
  branch: String!
  name: String!
}

union CustomDomainCreatePayload =
  | CustomDomainCreateSuccess
  | ProjectDoesNotExistError
  | BranchDoesNotExistError
  | CustomDomainAlreadyExistsError
  | TooManyCustomDomainsError
  | BranchNotDeployedError
  | OperationNotAllowedByPlanError
  | InvalidDomainError

type CustomDomainCreateSuccess {
  domain: CustomDomain!
  query: Query!
}

input CustomDomainDeleteInput {
  projectId: ID!
  name: String!
}

union CustomDomainDeletePayload = CustomDomainDeleteSuccess | CustomDomainDoesNotExistError

type CustomDomainDeleteSuccess {
  name: String!
  query: Query!
}

type CustomDomainDoesNotExistError {
  query: Query!
}

input CustomDomainReplaceInput {
  projectId: ID!
  existingName: String!
  branch: String!
  name: String!
}

union CustomDomainReplacePayload =
  | CustomDomainReplaceSuccess
  | CustomDomainDoesNotExistError
  | ProjectDoesNotExistError
  | BranchDoesNotExistError
  | BranchNotDeployedError
  | OperationNotAllowedByPlanError
  | InvalidDomainError

type CustomDomainReplaceSuccess {
  domain: CustomDomain!
  query: Query!
}

enum CustomDomainStatus {
  ACTIVE
  PENDING
  ERROR
}

type DailyDeploymentCountLimitExceededError {
  query: Query!
  limit: Int!
}

type DatabaseUsage {
  requestCount: Distribution!
  dbReads: Distribution!
  dbWrites: Distribution!
  dbSize: Distribution!
  buildDuration: Distribution!
  execUnits: Distribution!
  udfRequestCount: Distribution!
  granularity: DatabaseUsageGranularity!
}

enum DatabaseUsageGranularity {
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
}

type DatadogIntegration {
  apiKey: String!
  region: DatadogRegion!
  environments: [BranchEnvironment!]!
  sampling: Int!
}

input DatadogIntegrationInput {
  apiKey: String!
  region: DatadogRegion!
  environments: [BranchEnvironment!]!
  sampling: Int!
}

enum DatadogRegion {
  US1
  US3
  US5
  EU1
  US1_FED
  AP1
}

"""
RFC3339 formatted date in the UTC time zone denoted by letter 'Z'
"""
scalar DateTime

input DeleteSubgraphInput {
  accountSlug: String!
  projectSlug: String!
  branch: String!
  subgraph: String!
  dryRun: Boolean!
}

union DeleteSubgraphPayload =
  | DeleteSubgraphSuccess
  | SubgraphNotFoundError
  | ProjectDoesNotExistError
  | ProjectNotFederatedError
  | ProjectBranchDoesNotExistError
  | FederatedGraphCompositionError

type DeleteSubgraphSuccess {
  query: Query!
}

"""
Deployment
"""
type Deployment implements Node {
  id: ID!
  commit: GitCommit
  branch: Branch!
  createdAt: DateTime!
  startedAt: DateTime
  finishedAt: DateTime
  isRedeployable: Boolean!
  triggerType: DeploymentTriggerType!

  """
  The duration of the deployment in milliseconds.
  """
  duration: Int
  status: DeploymentStatus!
  logEntries: [DeploymentLogEntry!]!
  project: Project!
  schema: String
  diffAgainstPreviousBranchDeployment: String
  diffAgainstLatestProductionDeployment: String
}

type DeploymentConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [DeploymentEdge!]!

  """
  A list of nodes.
  """
  nodes: [Deployment!]!
}

input DeploymentCreateInput {
  projectId: ID!
  archiveFileSize: Int!
  branch: String
}

union DeploymentCreatePayload =
  | DeploymentCreateSuccess
  | ProjectDoesNotExistError
  | ArchiveFileSizeLimitExceededError
  | DailyDeploymentCountLimitExceededError
  | ProjectNotManagedError

type DeploymentCreateSuccess {
  deployment: Deployment!
  presignedUrl: String!
  query: Query!
}

type DeploymentDoesNotExistError {
  query: Query!
}

"""
An edge in a connection.
"""
type DeploymentEdge {
  """
  The item at the end of the edge
  """
  node: Deployment!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

input DeploymentFilter {
  branch: String
  statuses: [DeploymentStatus!]
}

type DeploymentLogEntry {
  createdAt: DateTime!
  message: String!
  level: DeploymentLogLevel!
}

enum DeploymentLogLevel {
  ERROR
  WARN
  INFO
}

union DeploymentRedeployPayload =
  | DeploymentRedeploySuccess
  | DeploymentDoesNotExistError
  | DailyDeploymentCountLimitExceededError

type DeploymentRedeploySuccess {
  deployment: Deployment!
  query: Query!
}

enum DeploymentStatus {
  QUEUED
  IN_PROGRESS
  SUCCEEDED
  FAILED
}

enum DeploymentTriggerType {
  PROJECT_CREATION
  GIT_PUSH
  CLI
  REDEPLOYMENT
  NEW_SCHEMA_PUBLICATION
  INTERNAL
}

type DisabledAccountError {
  query: Query!
}

type Distribution {
  unit: UnitType!
  values: [DistributionValue!]!
}

type DistributionValue {
  bucket: DateTime!
  value: Int!
}

type DuplicateDatabaseRegionsError {
  duplicates: [String!]!
  query: Query!
}

"""
Implement the Duration scalar

The input/output is a string in ISO8601 format.
"""
scalar Duration

type EmptyDatabaseRegionsError {
  query: Query!
}

type EnvironmentVariable implements Node {
  id: ID!
  name: String!
  value: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  environments: [BranchEnvironment!]!
  branches: [String!]
}

type EnvironmentVariableConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [EnvironmentVariableEdge!]!

  """
  A list of nodes.
  """
  nodes: [EnvironmentVariable!]!
}

type EnvironmentVariableCountLimitExceededError {
  query: Query!
}

input EnvironmentVariableCreateInput {
  projectId: ID!

  """
  Must not be already assigned.
  """
  name: String!
  value: String!
  environments: [BranchEnvironment!]!
}

union EnvironmentVariableCreatePayload =
  | EnvironmentVariableCreateSuccess
  | NameAlreadyExistsError
  | NameTooLongError
  | NameContainsInvalidCharactersError
  | ValueTooLongError
  | ReservedPrefixError
  | ProjectDoesNotExistError

type EnvironmentVariableCreateSuccess {
  environmentVariable: EnvironmentVariable!
  query: Query!
}

input EnvironmentVariableDeleteInput {
  id: ID!
}

union EnvironmentVariableDeletePayload = EnvironmentVariableDeleteSuccess | EnvironmentVariableDoesNotExistError

type EnvironmentVariableDeleteSuccess {
  deletedId: ID!
  query: Query!
}

type EnvironmentVariableDoesNotExistError {
  query: Query!
}

"""
An edge in a connection.
"""
type EnvironmentVariableEdge {
  """
  The item at the end of the edge
  """
  node: EnvironmentVariable!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

input EnvironmentVariableSpecification {
  name: String!
  value: String!
}

input EnvironmentVariableUpdateInput {
  id: ID!
  name: String
  value: String
  environments: [BranchEnvironment!]
}

union EnvironmentVariableUpdatePayload =
  | EnvironmentVariableUpdateSuccess
  | EnvironmentVariableDoesNotExistError
  | NameAlreadyExistsError
  | NameTooLongError
  | NameContainsInvalidCharactersError
  | ValueTooLongError
  | ReservedPrefixError

type EnvironmentVariableUpdateSuccess {
  environmentVariable: EnvironmentVariable!
  query: Query!
}

type FederatedGraphCompositionError {
  query: Query!
  messages: [String!]!
}

enum FunctionKind {
  AUTHORIZER
  RESOLVER
}

type FunctionLogEvent implements LogEvent {
  id: String!
  branch: String!
  environment: BranchEnvironment!
  deploymentId: ID!
  createdAt: DateTime!
  functionKind: FunctionKind!
  functionName: String!
  region: String!
  logLevel: LogLevel!
  url: String
  message: String!
}

type GatewayRequestLogEvent implements LogEvent {
  id: String!
  branch: String!
  environment: BranchEnvironment!
  deploymentId: ID!
  createdAt: DateTime!
  region: String!
  logLevel: LogLevel!
  httpMethod: String!
  httpStatus: Int!
  url: String!
  operation: GatewayRequestLogEventOperation
  duration: Int!
  message: String!
}

type GatewayRequestLogEventOperation {
  name: String
  type: OperationType!
}

type GitAccount {
  provider: GitProvider!
  id: ID!
  slug: String!
  type: GitAccountType!

  """
  Date when the app was authorized to access this account
  """
  connectedAt: DateTime!
}

enum GitAccountType {
  ORGANIZATION
  PERSONAL
}

union GitAccountsPayload = GitAccountsSuccess | GitHubAuthorizationError

type GitAccountsSuccess {
  accounts: [GitAccount!]!
  query: Query!
}

type GitCommit {
  sha: String!
  message: String!
  author: String
  authorAvatarUrl: String
}

type GitHubAuthorizationError {
  query: Query!
}

enum GitProvider {
  GITHUB
}

type GitRepository {
  provider: GitProvider!
  id: String!
  owner: String!
  slug: String!
  url: String!
  defaultBranch: String
  private: Boolean!
  updatedAt: DateTime!
  branches: [String!]!
}

type GithubInstallationInsufficientPermissionsError {
  query: Query!
}

enum GrafbasePlan {
  HOBBY
  PRO
  ENTERPRISE
}

enum GraphMode {
  MANAGED
  SELF_HOSTED
}

type HasAlreadyPaymentMethodError {
  query: Query!
}

enum InArrearsCause {
  NEVER_PAID
  UNPAID_INVOICE
}

type InvalidAccountError {
  query: Query!
}

type InvalidDatabaseRegionsError {
  invalid: [String!]!
  query: Query!
}

type InvalidDomainError {
  query: Query!
}

type InvalidEnvironmentVariableError {
  variableName: String!
  error: InvalidEnvironmentVariableErrorType!
}

enum InvalidEnvironmentVariableErrorType {
  NAME_TOO_LONG
  NAME_CONTAINS_INVALID_CHARACTERS
  VALUE_TOO_LONG
  RESERVED_PREFIX
  DUPLICATE
}

type InvalidEnvironmentVariablesError {
  errors: [InvalidEnvironmentVariableError!]!
}

type InvalidProjectRootPathError {
  query: Query!
}

type Invite implements Node {
  id: ID!
  role: MemberRole!
  email: String!
  invitedBy: User!
  lastRenewedAt: DateTime!
  status: InviteStatus!
  createdAt: DateTime!
  organization: Organization!
}

input InviteAcceptInput {
  id: ID!
}

union InviteAcceptPayload =
  | InviteAcceptSuccess
  | InviteDoesNotExistError
  | AlreadyMemberError
  | CannotUseInvitationsWithSSO

type InviteAcceptSuccess {
  member: Member!
  query: Query!
}

input InviteCancelInput {
  id: ID!
}

union InviteCancelPayload = InviteCancelSuccess | InviteDoesNotExistError | NotAllowedToCancelInvitesError

type InviteCancelSuccess {
  inviteId: ID!
  query: Query!
}

type InviteConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [InviteEdge!]!

  """
  A list of nodes.
  """
  nodes: [Invite!]!
}

input InviteDeclineInput {
  id: ID!
}

union InviteDeclinePayload = InviteDeclineSuccess | InviteDoesNotExistError

type InviteDeclineSuccess {
  inviteId: ID!
  query: Query!
}

type InviteDoesNotExistError {
  query: Query!
}

"""
An edge in a connection.
"""
type InviteEdge {
  """
  The item at the end of the edge
  """
  node: Invite!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

input InviteSendInput {
  organizationId: ID!
  email: String!
  role: MemberRole!
}

union InviteSendPayload =
  | InviteSendSuccess
  | OrganizationDoesNotExistError
  | NotAllowedToSendInvitesError
  | CannotUseInvitationsWithSSO

type InviteSendSuccess {
  invite: Invite!
  query: Query!
}

enum InviteStatus {
  PENDING
  EXPIRED
}

type KeyDoesNotExistError {
  query: Query!
}

type KeyLimitExceededError {
  query: Query!
}

"""
Users can select the previous/current "limit cycle" which defines the cycle on which limits
applies. For hobby it's monthly starting the first of each month and for pro it matches the
billing cycle.
"""
enum LimitCycleChoice {
  CURRENT
  PREVIOUS
}

type LintCheckError {
  title: String!
  message: String!
  severity: SchemaCheckErrorSeverity!
}

interface LogEvent {
  id: String!
  createdAt: DateTime!
  region: String!
  logLevel: LogLevel!
  deploymentId: ID!
  branch: String!
  environment: BranchEnvironment!
  message: String!
}

type LogEventConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [LogEventEdge!]!

  """
  A list of nodes.
  """
  nodes: [LogEvent!]!
}

"""
An edge in a connection.
"""
type LogEventEdge {
  """
  The item at the end of the edge
  """
  node: LogEvent!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

input LogEventFilter {
  query: String
  branch: String
  from: DateTime
  to: DateTime
  region: [String!]
  logLevel: [LogLevel!]
}

enum LogLevel {
  DEBUG
  INFO
  WARN
  ERROR
}

type Member implements Node {
  id: ID!
  role: MemberRole!
  createdAt: DateTime!
  account: Account!
  user: User!
}

type MemberConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [MemberEdge!]!

  """
  A list of nodes.
  """
  nodes: [Member!]!
}

input MemberDeleteInput {
  id: ID!
}

type MemberDeletePayload {
  deletedMemberId: ID!
  query: Query!
}

"""
An edge in a connection.
"""
type MemberEdge {
  """
  The item at the end of the edge
  """
  node: Member!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

enum MemberRole {
  OWNER
  MEMBER
}

input MemberUpdateInput {
  id: ID!
  role: MemberRole
}

type MemberUpdatePayload {
  member: Member!
  query: Query!
}

type MissingStripeCustomerError {
  query: Query!
}

type MustLeaveAtLeastOneKeyForEnvironmentError {
  query: Query!
}

type Mutation {
  """
  Create a new access token.
  """
  accessTokenCreate(input: AccessTokenCreateInput!): AccessTokenCreatePayload!

  """
  Delete a given access token.
  """
  accessTokenDelete(input: AccessTokenDeleteInput!): AccessTokenDeletePayload!

  """
  Create new organization account owned by the current user. Slug must be unique.
  """
  organizationCreate(input: OrganizationCreateInput!): OrganizationCreatePayload!
  organizationSlugUpdate(input: OrganizationSlugUpdateInput!): OrganizationSlugUpdatePayload!
  personalAccountSlugUpdate(input: PersonalAccountSlugUpdateInput!): PersonalAccountSlugUpdatePayload!
  organizationPaymentMethodReplace(
    accountId: ID!
    stripePaymentMethodId: String!
  ): OrganizationPaymentMethodReplacePayload!
  organizationSetupPaymentMethod(accountId: ID!, stripePaymentMethodId: String!): OrganizationSetupPaymentMethod!
  organizationUpdate(input: OrganizationUpdateInput!): OrganizationUpdatePayload!
  personalAccountUpdate(input: PersonalAccountUpdateInput!): PersonalAccountUpdatePayload!
  personalAccountDelete: PersonalAccountDeletePayload!
  organizationDelete(input: OrganizationDeleteInput!): OrganizationDeletePayload!
  accountIntegrationCreate(accountId: ID!, input: AccountIntegrationInput!): AccountIntegrationMutationPayload!
  accountIntegrationUpdate(id: ID!, input: AccountIntegrationInput!): AccountIntegrationMutationPayload!
  accountIntegrationDelete(id: ID!): AccountIntegrationMutationPayload!

  """
  Add a new custom domain.
  """
  customDomainCreate(input: CustomDomainCreateInput!): CustomDomainCreatePayload!

  """
  Delete a custom domain.
  """
  customDomainDelete(input: CustomDomainDeleteInput!): CustomDomainDeletePayload!

  """
  Replace a configured custom domain with another one (domain and target branch) â€“ or modify the target branch of an existing one
  without changing the domain name.
  """
  customDomainReplace(input: CustomDomainReplaceInput!): CustomDomainReplacePayload!

  """
  Create a new deployment for an existing project.
  """
  deploymentCreate(input: DeploymentCreateInput!): DeploymentCreatePayload!

  """
  Create a new deployment for an existing project.
  """
  deploymentRedeploy(
    """
    ID of the deployment
    """
    id: ID!
  ): DeploymentRedeployPayload!

  """
  Create a new environment variable.
  """
  environmentVariableCreate(input: EnvironmentVariableCreateInput!): EnvironmentVariableCreatePayload!

  """
  Update an environment variable.
  """
  environmentVariableUpdate(input: EnvironmentVariableUpdateInput!): EnvironmentVariableUpdatePayload!

  """
  Delete an environment variable.
  """
  environmentVariableDelete(input: EnvironmentVariableDeleteInput!): EnvironmentVariableDeletePayload!
  inviteSend(input: InviteSendInput!): InviteSendPayload!
  inviteCancel(input: InviteCancelInput!): InviteCancelPayload!
  inviteAccept(input: InviteAcceptInput!): InviteAcceptPayload!
  inviteDecline(input: InviteDeclineInput!): InviteDeclinePayload!

  """
  Update role of an organization member
  """
  memberUpdate(input: MemberUpdateInput!): MemberUpdatePayload!

  """
  Remove member from an organization
  """
  memberDelete(input: MemberDeleteInput!): MemberDeletePayload!

  """
  Create a new project API key.
  """
  projectApiKeyCreate(input: ProjectApiKeyCreateInput!): ProjectApiKeyCreatePayload!

  """
  Update a given API key with a new name.
  """
  projectApiKeyUpdate(input: ProjectApiKeyUpdateInput!): ProjectApiKeyUpdatePayload!

  """
  Delete a given API key.
  """
  projectApiKeyDelete(input: ProjectApiKeyDeleteInput!): ProjectApiKeyDeletePayload!

  """
  Create a new project without any source for an initial deployment.
  """
  projectCreate(input: ProjectCreateInput!): ProjectCreatePayload!

  """
  Create a new project from a GitHub repository.
  """
  projectCreateFromSchema(input: ProjectCreateFromSchemaInput!): ProjectCreateFromSchemaPayload!

  """
  Create a new project from a GitHub repository.
  """
  projectCreateFromRepository(input: ProjectCreateFromRepositoryInput!): ProjectCreateFromRepositoryPayload!

  """
  Create a new project from a template in a newly created GitHub repository.
  """
  projectCreateFromTemplate(input: ProjectCreateFromTemplateInput!): ProjectCreateFromTemplatePayload!
  projectUpdate(input: ProjectUpdateInput!): ProjectUpdatePayload!
  projectOperationCheckConfigurationUpdate(
    input: ProjectOperationCheckConfigurationInput!
  ): ProjectOperationCheckConfigurationUpdatePayload!
  projectDelete(input: ProjectDeleteInput!): ProjectDeletePayload!

  """
  Run checks against the given schema
  """
  schemaCheckCreate(input: SchemaCheckCreateInput!): SchemaCheckPayload!

  """
  Publish a new subgraph.
  """
  publish(input: PublishInput!): PublishPayload!

  """
  Delete a subgraph
  """
  deleteSubgraph(input: DeleteSubgraphInput!): DeleteSubgraphPayload!
  stripeSetupIntentCreate: StripeSetupIntentCreatePayload!
  branchUpdate(input: BranchUpdateInput!): BranchUpdatePayload!
  branchDelete(
    """
    slug of the account
    """
    accountSlug: String!

    """
    slug of the project
    """
    projectSlug: String!

    """
    name of the branch
    """
    branchName: String!
  ): BranchDeletePayload!
  slackIntegrationCreate(input: SlackIntegrationCreateInput!): SlackNotificationCreatePayload!
  slackNotificationDelete(id: String!): SlackNotificationDeletePayload!
  trustedDocumentsSubmit(
    accountSlug: String
    projectSlug: String!
    branchSlug: String!
    clientName: String!
    documents: [TrustedDocumentInput!]!
  ): TrustedDocumentsSubmitPayload!
}

type NameAlreadyExistsError {
  query: Query!
}

type NameContainsInvalidCharactersError {
  query: Query!
}

type NameSizeCheckError {
  maxLength: Int!
  message: String!
  query: Query!
}

type NameTooLongError {
  query: Query!
}

interface Node {
  id: ID!
}

type NotAllowedError {
  query: Query!
}

type NotAllowedToCancelInvitesError {
  query: Query!
}

type NotAllowedToDeleteOrganizationError {
  query: Query!
}

type NotAllowedToSendInvitesError {
  query: Query!
}

type NotAllowedToSlugUpdateError {
  query: Query!
}

type NotAllowedToUpdateOrganizationError {
  query: Query!
}

type OldAccessTokenError {
  query: Query!
}

type Operation implements Node {
  name: String
  type: OperationType!
  normalizedQuery: String!
  id: ID!
}

type OperationCheckError {
  title: String!
  message: String!
  severity: SchemaCheckErrorSeverity!
}

type OperationNotAllowedByPlanError {
  query: Query!
}

input OperationRequestAnalyticsFilter {
  branch: String
  period: ProjectRequestAnalyticsPeriod!
  now: DateTime!
  operationName: String
  operationTypes: [OperationType!]
}

type OperationRequestMetrics {
  operationType: OperationType!
  operationName: String!
  operationId: ID!
  requestCount: Int!
}

type OperationRequestMetricsConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [OperationRequestMetricsEdge!]!

  """
  A list of nodes.
  """
  nodes: [OperationRequestMetrics!]!
}

"""
An edge in a connection.
"""
type OperationRequestMetricsEdge {
  """
  The item at the end of the edge
  """
  node: OperationRequestMetrics!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

enum OperationType {
  QUERY
  MUTATION
  SUBSCRIPTION
}

type OrbBillingAddress {
  city: String
  country: String
  line1: String
  line2: String
  postalCode: String
  state: String
}

input OrbBillingAddressInput {
  city: String
  country: String
  line1: String
  line2: String
  postalCode: String
  state: String
}

type OrbCustomer {
  id: String!
  name: String!
  email: String!
  taxId: OrbTaxId
  billingAddress: OrbBillingAddress
  subscriptions(cursor: String): OrbPaginatedSubscriptions!
}

input OrbCustomerUpdateInput {
  name: String
  email: String
  billingAddress: OrbBillingAddressInput
  taxId: OrbTaxIdInput
}

type OrbInvoice {
  id: String!
  dueDate: DateTime!
  invoiceDate: DateTime!
  status: OrbInvoiceStatus!
  total: String!
  currency: String!
  lineItems: [OrbInvoiceLineItem!]!
  invoicePdf: Url!
  invoiceNumber: String!
}

type OrbInvoiceLineItem {
  id: String!
  name: String!
  quantity: Float!
  amount: String!
  price: OrbPrice!
  startDate: DateTime!
  endDate: DateTime!
}

enum OrbInvoiceStatus {
  ISSUED
  PAID
  SYNCED
  VOID
  DRAFT
}

type OrbPaginatedInvoices {
  data: [OrbInvoice!]!
  paginationMetadata: OrbPaginationMetadata!
}

type OrbPaginatedSubscriptions {
  data: [OrbSubscription!]!
  paginationMetadata: OrbPaginationMetadata!
}

type OrbPaginationMetadata {
  nextCursor: String
}

type OrbPlan {
  externalPlanId: String
}

type OrbPrice {
  currency: String!
  modelType: OrbPriceModelType!
  unitConfig: OrbPriceUnitConfig
  packageConfig: OrbPricePackageConfig
}

enum OrbPriceModelType {
  UNIT
  TIERED
  BULK
  PACKAGE
  BPS
  TIERED_BPS
  BULK_BPS
  MATRIX
}

type OrbPricePackageConfig {
  packageAmount: String!
  packageSize: Float!
}

type OrbPriceUnitConfig {
  unitAmount: String!
}

type OrbSubscription {
  id: String!
  status: OrbSubscriptionStatus!
  plan: OrbPlan!
  currentBillingPeriodStartDate: DateTime
  currentBillingPeriodEndDate: DateTime
  endDate: DateTime
  invoices(cursor: String): OrbPaginatedInvoices!
  upcomingInvoice: OrbUpcomingInvoice
}

enum OrbSubscriptionStatus {
  ACTIVE
  ENDED
  UPCOMING
}

type OrbTaxId {
  type: OrbTaxIdType!
  value: String!
  country: String!
}

input OrbTaxIdInput {
  type: OrbTaxIdType!
  value: String!
  country: String!
}

enum OrbTaxIdType {
  AE_TRN
  AU_ABN
  AU_ARN
  BG_UIC
  BR_CNPJ
  BR_CPF
  CA_BN
  CA_GST_HST
  CA_PST_BC
  CA_PST_MB
  CA_PST_SK
  CA_QST
  CH_VAT
  CL_TIN
  EG_TIN
  ES_CIF
  EU_OSS_VAT
  EU_VAT
  GB_VAT
  GE_VAT
  HK_BR
  HU_TIN
  ID_NPWP
  IL_VAT
  IN_GST
  IS_VAT
  JP_CN
  JP_RN
  JP_TRN
  KE_PIN
  KR_BRN
  LI_UID
  MX_RFC
  MY_FRP
  MY_ITN
  MY_SST
  NO_VAT
  NZ_GST
  PH_TIN
  RU_INN
  RU_KPP
  SA_VAT
  SG_GST
  SG_UEN
  SI_TIN
  TH_VAT
  TR_TIN
  TW_VAT
  UA_VAT
  US_EIN
  ZA_VAT
}

type OrbUpcomingInvoice {
  targetDate: DateTime!
  subtotal: String!
  currency: String!
  lineItems: [OrbUpcomingInvoiceLineItem!]!
}

type OrbUpcomingInvoiceLineItem {
  name: String!
  quantity: Float!
  amount: String!
  startDate: DateTime!
  endDate: DateTime!
  price: OrbPrice!
}

type OrbValidationError {
  errors: [String!]!
  query: Query!
}

type Organization implements Account {
  id: ID!
  slug: String!
  name: String!
  createdAt: DateTime!
  status: AccountStatus!
  plan: GrafbasePlan!
  samlDomain: String
  stripeCustomer: StripeCustomer
  orbCustomer: OrbCustomer
  orbActiveSubscription: OrbSubscription
  projects(after: String, before: String, first: Int, last: Int): ProjectConnection!
  integrations: [AccountIntegration!]!
  invites(after: String, before: String, first: Int, last: Int): InviteConnection!
  members(after: String, before: String, first: Int, last: Int): MemberConnection!
  projectsCountStatus: ResourceStatus!
  slackIntegration: SlackIntegration

  """
  The url for the UI button to install the Grafbase slack app. It is
  important to use this link and keep it private, since it contains the signed
  account id of the authenticated user.
  """
  addToSlackLink: String!
  usage(filter: AccountResourcesUsageDashboardFilter): DatabaseUsage!
    @deprecated(reason: "Use resources_usage_dashboard")
  resourcesUsageDashboard(filter: AccountResourcesUsageDashboardFilter): AccountResourcesUsageDashboardPayload!
  accessTokens(after: String, before: String, first: Int, last: Int): AccessTokenConnection!
  resources: AccountResources! @deprecated(reason: "Not relevant for organizations")
}

type OrganizationConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [OrganizationEdge!]!

  """
  A list of nodes.
  """
  nodes: [Organization!]!
}

input OrganizationCreateInput {
  slug: String!
  name: String!
  email: String
  stripePaymentMethodId: String!
}

union OrganizationCreatePayload =
  | OrganizationCreateSuccess
  | SlugError
  | SlugSizeCheckError
  | NameSizeCheckError
  | ReservedSlugsCheckError
  | SlugAlreadyExistsError

type OrganizationCreateSuccess {
  organization: Organization!
  member: Member!
  query: Query!
}

input OrganizationDeleteInput {
  id: ID!
}

union OrganizationDeletePayload =
  | OrganizationDeleteSuccess
  | OrganizationDoesNotExistError
  | NotAllowedToDeleteOrganizationError

type OrganizationDeleteSuccess {
  deletedId: ID!
  query: Query!
}

type OrganizationDoesNotExistError {
  query: Query!
}

"""
An edge in a connection.
"""
type OrganizationEdge {
  """
  The item at the end of the edge
  """
  node: Organization!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type OrganizationOwnershipNotTransferredError {
  query: Query!
}

union OrganizationPaymentMethodReplacePayload =
  | OrganizationSuccessfulUpdate
  | MissingStripeCustomerError
  | OrganizationDoesNotExistError
  | NotAllowedError

union OrganizationSetupPaymentMethod =
  | OrganizationUpgradeToProSuccess
  | HasAlreadyPaymentMethodError
  | OrganizationDoesNotExistError
  | NotAllowedError

input OrganizationSlugUpdateInput {
  id: ID!
  slug: String!
}

union OrganizationSlugUpdatePayload =
  | OrganizationSlugUpdateSuccess
  | SlugError
  | SlugSizeCheckError
  | ReservedSlugsCheckError
  | SlugAlreadyExistsError
  | OrganizationDoesNotExistError
  | NotAllowedToSlugUpdateError

type OrganizationSlugUpdateSuccess {
  organization: Organization!
  query: Query!
}

type OrganizationSuccessfulUpdate {
  organization: Organization!
  query: Query!
}

input OrganizationUpdateInput {
  id: ID!
  name: String
  orbCustomer: OrbCustomerUpdateInput
}

union OrganizationUpdatePayload =
  | OrganizationUpdateSuccess
  | OrganizationDoesNotExistError
  | NameSizeCheckError
  | NotAllowedToUpdateOrganizationError
  | OrbValidationError

type OrganizationUpdateSuccess {
  organization: Organization!
  query: Query!
}

type OrganizationUpgradeToProSuccess {
  organization: Organization!
  query: Query!
}

"""
Information about pagination in a connection
"""
type PageInfo {
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!

  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!

  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: String

  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: String
}

type PersonalAccount implements Account {
  id: ID!
  slug: String!
  name: String!
  createdAt: DateTime!
  status: AccountStatus!
  plan: GrafbasePlan!
  projects(after: String, before: String, first: Int, last: Int): ProjectConnection!
  projectsCountStatus: ResourceStatus!
  usage(filter: AccountResourcesUsageDashboardFilter): DatabaseUsage!
    @deprecated(reason: "Use resources_usage_dashboard")
  resourcesUsageDashboard(filter: AccountResourcesUsageDashboardFilter): AccountResourcesUsageDashboardPayload!
  resources: AccountResources! @deprecated(reason: "use projects_count_status")
  accessTokens(after: String, before: String, first: Int, last: Int): AccessTokenConnection!
}

union PersonalAccountDeletePayload = PersonalAccountDeleteSuccess | OrganizationOwnershipNotTransferredError

type PersonalAccountDeleteSuccess {
  deletedId: ID!
  query: Query!
}

input PersonalAccountSlugUpdateInput {
  slug: String!
}

union PersonalAccountSlugUpdatePayload =
  | PersonalAccountSlugUpdateSuccess
  | SlugError
  | SlugSizeCheckError
  | ReservedSlugsCheckError
  | SlugAlreadyExistsError

type PersonalAccountSlugUpdateSuccess {
  query: Query!
}

input PersonalAccountUpdateInput {
  name: String!
}

union PersonalAccountUpdatePayload = PersonalAccountUpdateSuccess | NameSizeCheckError

type PersonalAccountUpdateSuccess {
  query: Query!
}

type Project implements Node {
  id: ID!
  accountSlug: String!
  slug: String!
  projectRootPath: String!
  projectType: ProjectType
  graphMode: GraphMode!
  createdAt: DateTime!
  canBeRenamed: Boolean!
  repository: GitRepository
  branches(after: String, before: String, first: Int, last: Int): BranchConnection!
  apiKeys(after: String, before: String, first: Int, last: Int): ProjectApiKeyConnection!
  productionBranch: Branch!
  environmentVariables(after: String, before: String, first: Int, last: Int): EnvironmentVariableConnection!
  deployments(after: String, before: String, first: Int, last: Int, filter: DeploymentFilter): DeploymentConnection!
  status: ProjectStatus!
  customDomains: [CustomDomain!]!
  requestAnalytics(filter: ProjectRequestAnalyticsFilter!): RequestAnalytics!
  operationAnalytics(
    first: Int
    after: String
    filter: OperationRequestAnalyticsFilter!
  ): OperationRequestMetricsConnection!
  schemaChecks(first: Int, after: String, branch: String): SchemaCheckConnection!
  operationChecksConfiguration: ProjectOperationCheckConfiguration!
  logEvents(first: Int, after: String, last: Int, before: String, filter: LogEventFilter!): LogEventConnection!
}

type ProjectApiKey implements Node {
  id: ID!
  key: String!
  environment: BranchEnvironment!
  createdAt: DateTime!
  name: String!
}

type ProjectApiKeyConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [ProjectApiKeyEdge!]!

  """
  A list of nodes.
  """
  nodes: [ProjectApiKey!]!
}

input ProjectApiKeyCreateInput {
  projectId: ID!
  environment: BranchEnvironment!
  name: String!
}

union ProjectApiKeyCreatePayload = ProjectApiKeyCreateSuccess | KeyLimitExceededError | ProjectDoesNotExistError

type ProjectApiKeyCreateSuccess {
  apiKey: ProjectApiKey!
  query: Query!
}

input ProjectApiKeyDeleteInput {
  id: ID!
}

union ProjectApiKeyDeletePayload =
  | ProjectApiKeyDeleteSuccess
  | KeyDoesNotExistError
  | MustLeaveAtLeastOneKeyForEnvironmentError

type ProjectApiKeyDeleteSuccess {
  deletedId: ID!
  query: Query!
}

"""
An edge in a connection.
"""
type ProjectApiKeyEdge {
  """
  The item at the end of the edge
  """
  node: ProjectApiKey!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

input ProjectApiKeyUpdateInput {
  id: ID!
  name: String!
}

union ProjectApiKeyUpdatePayload = ProjectApiKeyUpdateSuccess | KeyDoesNotExistError

type ProjectApiKeyUpdateSuccess {
  query: Query!
}

type ProjectBranchDoesNotExistError {
  query: Query!
}

type ProjectConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [ProjectEdge!]!

  """
  A list of nodes.
  """
  nodes: [Project!]!
}

input ProjectCreateFromRepositoryInput {
  accountId: ID!
  projectSlug: String!
  gitRepoUrl: Url!
  gitAccountId: String!
  productionBranch: String!
  environmentVariables: [EnvironmentVariableSpecification!]! = []
  projectRootPath: String! = "grafbase"
}

union ProjectCreateFromRepositoryPayload =
  | ProjectCreateFromRepositorySuccess
  | SlugAlreadyExistsError
  | DisabledAccountError
  | SlugInvalidError
  | SlugTooLongError
  | RepositoryContainsNoBranchesError
  | AccountDoesNotExistError
  | CurrentPlanLimitReachedError
  | EmptyDatabaseRegionsError
  | DuplicateDatabaseRegionsError
  | InvalidDatabaseRegionsError
  | EnvironmentVariableCountLimitExceededError
  | InvalidEnvironmentVariablesError
  | InvalidProjectRootPathError

type ProjectCreateFromRepositorySuccess {
  project: Project!
  query: Query!
}

input ProjectCreateFromSchemaInput {
  accountId: ID!
  projectSlug: String!
  schema: String!
  environmentVariables: [EnvironmentVariableSpecification!]! = []
}

union ProjectCreateFromSchemaPayload =
  | ProjectCreateFromSchemaSuccess
  | SlugAlreadyExistsError
  | DisabledAccountError
  | SlugInvalidError
  | SlugTooLongError
  | AccountDoesNotExistError
  | CurrentPlanLimitReachedError
  | EmptyDatabaseRegionsError
  | DuplicateDatabaseRegionsError
  | InvalidDatabaseRegionsError
  | EnvironmentVariableCountLimitExceededError
  | InvalidEnvironmentVariablesError

type ProjectCreateFromSchemaSuccess {
  project: Project!
  query: Query!
}

input ProjectCreateFromTemplateInput {
  accountId: ID!
  projectSlug: String!
  templateGitUrl: Url!
  gitAccountId: String!
  repoSlug: String!
  repoPrivate: Boolean!
  environmentVariables: [EnvironmentVariableSpecification!]! = []
  projectRootPath: String! = "grafbase"
}

union ProjectCreateFromTemplatePayload =
  | ProjectCreateFromTemplateSuccess
  | SlugAlreadyExistsError
  | DisabledAccountError
  | SlugInvalidError
  | SlugTooLongError
  | RepositorySlugInUseError
  | TemplateDoesNotExistError
  | AccountDoesNotExistError
  | CurrentPlanLimitReachedError
  | EmptyDatabaseRegionsError
  | DuplicateDatabaseRegionsError
  | InvalidDatabaseRegionsError
  | EnvironmentVariableCountLimitExceededError
  | InvalidEnvironmentVariablesError
  | InvalidProjectRootPathError
  | GithubInstallationInsufficientPermissionsError

type ProjectCreateFromTemplateSuccess {
  project: Project!
  query: Query!
}

input ProjectCreateInput {
  accountId: ID!
  projectSlug: String!
  environmentVariables: [EnvironmentVariableSpecification!]! = []
  projectRootPath: String! = "grafbase"
  graphMode: GraphMode! = MANAGED
  projectType: ProjectType
}

union ProjectCreatePayload =
  | ProjectCreateSuccess
  | SlugAlreadyExistsError
  | DisabledAccountError
  | SlugInvalidError
  | SlugTooLongError
  | AccountDoesNotExistError
  | CurrentPlanLimitReachedError
  | EmptyDatabaseRegionsError
  | DuplicateDatabaseRegionsError
  | InvalidDatabaseRegionsError
  | EnvironmentVariableCountLimitExceededError
  | InvalidEnvironmentVariablesError
  | InvalidProjectRootPathError

type ProjectCreateSuccess {
  project: Project!
  query: Query!
}

input ProjectDeleteInput {
  id: ID!
}

union ProjectDeletePayload = ProjectDeleteSuccess | ProjectDoesNotExistError

type ProjectDeleteSuccess {
  query: Query!
}

type ProjectDoesNotExistError {
  query: Query!
}

"""
An edge in a connection.
"""
type ProjectEdge {
  """
  The item at the end of the edge
  """
  node: Project!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type ProjectIntegration {
  accountIntegrationId: ID!
  createdAt: DateTime!
  enabled: Boolean!
  id: ID!
  project: Project!
}

type ProjectNotFederatedError {
  query: Query!
}

type ProjectNotManagedError {
  query: Query!
}

type ProjectOperationCheckConfiguration {
  """
  Whether operation checks are enabled for the project.
  """
  enabled: Boolean! @deprecated(reason: "Operation checks are now enabled exclusively at the branch level")

  """
  The time range in days to consider for operation checks. Operations older than the specificied
  number of days are ignored.
  """
  timeRangeDays: Int!

  """
  The request count threshold to consider for operation checks. Operations that have been
  registered less than the specified number of occurrences are ignored.
  """
  requestCountThreshold: Int!

  """
  The clients to exclude from operation checks.
  """
  excludedClients: [String!]!

  """
  The operations to exclude from operation checks.
  """
  excludedOperations: [String!]!
}

input ProjectOperationCheckConfigurationInput {
  """
  The project to update.
  """
  projectId: ID!

  """
  Whether operation checks are enabled for the project. This is ignored, since operation checks are now only enabled at the branch level.
  """
  enabled: Boolean

  """
  The time range in days to consider for operation checks. Operations older than the specificied
  number of days are ignored.
  """
  timeRangeDays: Int

  """
  The request count threshold to consider for operation checks. Operations that have been
  registered less than the specified number of occurrences are ignored.
  """
  requestCountThreshold: Int

  """
  The clients to exclude from operation checks.
  """
  excludedClients: [String!]

  """
  The operations to exclude from operation checks.
  """
  excludedOperations: [String!]
}

union ProjectOperationCheckConfigurationUpdatePayload = ProjectDoesNotExistError | ProjectOperationCheckConfiguration

input ProjectRequestAnalyticsFilter {
  branch: String = null
  period: ProjectRequestAnalyticsPeriod!
  now: DateTime!
  graphqlOperation: String
  operationId: ID
}

enum ProjectRequestAnalyticsPeriod {
  LAST_HOUR
  LAST_24_HOURS
  LAST_7_DAYS
}

type ProjectScopeLimitExceededError {
  query: Query!
}

enum ProjectStatus {
  ACTIVE
  INACTIVE
}

enum ProjectType {
  STANDALONE
  FEDERATED
}

input ProjectUpdateInput {
  id: ID!
  projectSlug: String
  productionBranch: String
  projectRootPath: String
}

union ProjectUpdatePayload =
  | ProjectUpdateSuccess
  | ProjectDoesNotExistError
  | SlugAlreadyExistsError
  | SlugInvalidError
  | SlugTooLongError
  | CannotBeRenamedError

type ProjectUpdateSuccess {
  project: Project!
  query: Query!
}

input PublishInput {
  accountSlug: String!
  projectSlug: String!
  branch: String
  subgraph: String!
  url: String!
  schema: String!
}

union PublishPayload =
  | PublishSuccess
  | ProjectDoesNotExistError
  | ProjectNotFederatedError
  | FederatedGraphCompositionError
  | SchemaRegistryBranchDoesNotExistError

type PublishSuccess {
  query: Query!
}

type Query {
  accessTokens(after: String, before: String, first: Int, last: Int): AccessTokenConnection!
  accountBySlug(
    """
    slug of the account
    """
    slug: String!
  ): Account
  accountCreationValidate(input: AccountCreationValidateInput!): AccountCreationValidatePayload!
  metricsByBranch(
    accountSlug: String!
    projectSlug: String!
    branch: String!
    startDate: DateTime!
    endDate: DateTime!
  ): BranchMetricsPayload!

  """
  Get branch by account slug, project slug and the name of the branch.
  """
  branch(
    """
    slug of the account
    """
    accountSlug: String!

    """
    slug of the project
    """
    projectSlug: String!

    """
    name of the branch
    """
    name: String!
  ): Branch

  """
  Get branch by domain.
  """
  branchByDomain(
    """
    domain
    """
    domain: String!
  ): Branch

  """
  Get custom domain by project id and name.
  """
  customDomainByName(
    """
    id of the project
    """
    projectId: ID!

    """
    name of the domain
    """
    name: String!
  ): CustomDomain

  """
  Get deployment by ID.
  """
  deployment(
    """
    ID of the deployment
    """
    id: ID!
  ): Deployment

  """
  Return a list of git accounts accessible by the current user sorted by the creation date.
  """
  gitAccounts(provider: GitProvider!): GitAccountsPayload!

  """
  Return a list of git repositories accessible by the current user, sorted by updatedAt.
  With `query` specified, the list will include up to 10 repos matching the query.
  Without `query`, the list will include the 10 most recently updated repos.
  """
  gitRepos(provider: GitProvider!, gitAccountId: String!, query: String): [GitRepository!]!

  """
  Returns details about a specific git repository identified by its URL.
  """
  gitRepoByUrl(url: Url!): GitRepository!

  """
  Returns the contents of the `schema.graphql` file located in a particular branch of a repository idenitifed by its URL.
  """
  schema(url: Url!, branch: String!): String
  invite(id: ID!): Invite

  """
  Get project by account slug and slug of the project itself.
  """
  projectByAccountSlug(
    """
    slug of the account
    """
    accountSlug: String!

    """
    slug of the project
    """
    projectSlug: String!
  ): Project

  """
  Get project by ID.
  """
  projectById(
    """
    ID of the project
    """
    id: ID!
  ): Project @deprecated(reason: "use the top-level `node` query")
  schemaCheck(id: ID!): SchemaCheck

  """
  Get subgraph.
  """
  subgraph(
    """
    account slug
    """
    accountSlug: String!

    """
    project slug
    """
    projectSlug: String!

    """
    name of the branch
    """
    branch: String

    """
    name of the subgraph
    """
    subgraphName: String!
  ): Subgraph
  schemaVersion(id: ID!): SchemaVersion
  schemaVersions(
    """
    account slug
    """
    accountSlug: String!

    """
    project slug
    """
    projectSlug: String!

    """
    name of the branch
    """
    branch: String

    """
    name of the subgraph
    """
    subgraphName: String
    after: String
    before: String
    first: Int
    last: Int
  ): SchemaVersionConnection!

  """
  Give the actual connected user.
  """
  viewer: User
  node(id: ID!): Node
}

type RepositoryContainsNoBranchesError {
  query: Query!
}

type RepositorySlugInUseError {
  query: Query!
}

type RequestAnalytics {
  timeSeries: RequestMetricsTimeSeries!
  metrics: RequestMetrics!
  periodStart: DateTime!
  periodEnd: DateTime!
}

type RequestLogEvent implements LogEvent {
  id: String!
  branch: String!
  environment: BranchEnvironment!
  deploymentId: ID!
  createdAt: DateTime!
  region: String!
  logLevel: LogLevel!
  url: String!
  httpMethod: String!
  httpStatus: Int!
  duration: Int!
  message: String!
}

type RequestMetrics {
  requestCount: Int!
  cacheableRequestCount: Int!
  cacheHitCount: Int!
  cacheMissCount: Int!
  cachePassCount: Int!
  error4XxCount: Int!
  error5XxCount: Int!
  errorGraphqlCount: Int!
  latencyMsP95: Int
  latencyMsP99: Int
}

type RequestMetricsTimeSeries {
  data: [RequestMetricsTimeSeriesDataPoint!]!
  aggregationStep: Duration!
}

type RequestMetricsTimeSeriesDataPoint {
  dateTime: DateTime!
  requestCount: Int!
  cacheableRequestCount: Int!
  cacheHitCount: Int!
  cacheMissCount: Int!
  cachePassCount: Int!
  error4XxCount: Int!
  error5XxCount: Int!
  errorGraphqlCount: Int!
  latencyMsP95: Int
  latencyMsP99: Int
}

type ReservedPrefixError {
  query: Query!
}

type ReservedSlugsCheckError {
  message: String!
  query: Query!
}

type ResourceStatus {
  unit: UnitType!
  used: Int!
  limit: Int
  remaining: Int
  percentage: Float
}

"""
An occurrence of a trusted document that was submitted again (same id), but with a different document text. This is an error.
"""
type ReusedId {
  """
  The document id
  """
  documentId: String!

  """
  The existing document body
  """
  existingDocumentText: String!

  """
  The different, newly submitted document body
  """
  newDocumentText: String!
}

"""
Trusted documents that were uploaded again (same id), but with a different document body. This is an error.
"""
type ReusedIds {
  reused: [ReusedId!]!
}

enum SchemaChangeType {
  SCHEMA_DEFINITION_ADDED
  SCHEMA_DEFINITION_REMOVED
  FIELD_ARGUMENT_DEFAULT_ADDED
  FIELD_ARGUMENT_DEFAULT_REMOVED
  FIELD_ARGUMENT_DESCRIPTION_CHANGED
  FIELD_ARGUMENT_DEFAULT_CHANGED
  FIELD_ARGUMENT_TYPE_CHANGED
  DIRECTIVE_REMOVED
  DIRECTIVE_ADDED
  DIRECTIVE_DESCRIPTION_CHANGED
  DIRECTIVE_LOCATION_ADDED
  DIRECTIVE_LOCATION_REMOVED
  DIRECTIVE_ARGUMENT_ADDED
  DIRECTIVE_ARGUMENT_REMOVED
  DIRECTIVE_ARGUMENT_DESCRIPTION_CHANGED
  DIRECTIVE_ARGUMENT_DEFAULT_VALUE_CHANGED
  DIRECTIVE_ARGUMENT_TYPE_CHANGED
  ENUM_ADDED
  ENUM_REMOVED
  ENUM_VALUE_REMOVED
  ENUM_VALUE_ADDED
  ENUM_VALUE_DESCRIPTION_CHANGED
  ENUM_VALUE_DEPRECATION_REASON_CHANGED
  ENUM_VALUE_DEPRECATION_REASON_ADDED
  ENUM_VALUE_DEPRECATION_REASON_REMOVED
  FIELD_REMOVED
  FIELD_ADDED
  FIELD_DESCRIPTION_CHANGED
  FIELD_DESCRIPTION_ADDED
  FIELD_DESCRIPTION_REMOVED
  FIELD_DEPRECATION_ADDED
  FIELD_DEPRECATION_REMOVED
  FIELD_DEPRECATION_REASON_CHANGED
  FIELD_DEPRECATION_REASON_ADDED
  FIELD_DEPRECATION_REASON_REMOVED
  FIELD_TYPE_CHANGED
  FIELD_ARGUMENT_ADDED
  FIELD_ARGUMENT_REMOVED
  INPUT_OBJECT_REMOVED
  INPUT_OBJECT_ADDED
  INPUT_FIELD_REMOVED
  INPUT_FIELD_ADDED
  INPUT_FIELD_DESCRIPTION_ADDED
  INPUT_FIELD_DESCRIPTION_REMOVED
  INPUT_FIELD_DESCRIPTION_CHANGED
  INPUT_FIELD_DEFAULT_VALUE_CHANGED
  INPUT_FIELD_TYPE_CHANGED
  OBJECT_TYPE_INTERFACE_ADDED
  OBJECT_TYPE_INTERFACE_REMOVED
  SCHEMA_QUERY_TYPE_CHANGED
  SCHEMA_MUTATION_TYPE_CHANGED
  SCHEMA_SUBSCRIPTION_TYPE_CHANGED
  TYPE_REMOVED
  TYPE_ADDED
  TYPE_KIND_CHANGED
  TYPE_DESCRIPTION_CHANGED
  TYPE_DESCRIPTION_REMOVED
  TYPE_DESCRIPTION_ADDED
  UNION_ADDED
  UNION_REMOVED
  UNION_MEMBER_REMOVED
  UNION_MEMBER_ADDED
  INTERFACE_ADDED
  INTERFACE_REMOVED
  INTERFACE_IMPLEMENTATION_ADDED
  INTERFACE_IMPLEMENTATION_REMOVED
  SCALAR_ADDED
  SCALAR_REMOVED
}

type SchemaCheck {
  id: ID!
  schema: String!
  subgraphName: String
  publishedSchemaVersion: ID
  errorCount: Int!
  validationCheckErrors: [ValidationCheckError!]!
  compositionCheckErrors: [CompositionCheckError!]!
  operationCheckErrors: [OperationCheckError!]!
  lintCheckErrors: [LintCheckError!]!
  createdAt: DateTime!
  gitCommit: SchemaCheckGitCommit
}

type SchemaCheckConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [SchemaCheckEdge!]!

  """
  A list of nodes.
  """
  nodes: [SchemaCheck!]!
}

input SchemaCheckCreateInput {
  accountSlug: String!
  projectSlug: String!
  branch: String
  subgraphName: String
  schema: String!
  gitCommit: SchemaCheckGitCommitInput
}

"""
An edge in a connection.
"""
type SchemaCheckEdge {
  """
  The item at the end of the edge
  """
  node: SchemaCheck!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

enum SchemaCheckErrorSeverity {
  ERROR
  WARNING
}

type SchemaCheckGitCommit {
  branch: String!
  commitSha: String!
  commitUrl: String
  message: String!
  authorName: String!
  authorAvatarUrl: String
}

input SchemaCheckGitCommitInput {
  branch: String!
  commitSha: String!
  commitUrl: String
  message: String!
  authorName: String!
  authorAvatarUrl: String
}

union SchemaCheckPayload =
  | SchemaCheck
  | ProjectBranchDoesNotExistError
  | ProjectDoesNotExistError
  | SubgraphNameProvidedOnSingleProjectError
  | SubgraphNameProvidedOnStandaloneProjectError
  | SubgraphNameMissingOnFederatedProjectError

type SchemaRegistryBranchDoesNotExistError {
  query: Query!
}

type SchemaVersion {
  id: ID!
  schema: String!
  delta: SchemaVersionDelta!
  changes(after: String, before: String, first: Int, last: Int): SchemaVersionChangeConnection!
  createdAt: DateTime!
}

type SchemaVersionChange {
  path: String
  type: SchemaChangeType!
  message: String!
}

type SchemaVersionChangeConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [SchemaVersionChangeEdge!]!

  """
  A list of nodes.
  """
  nodes: [SchemaVersionChange!]!
}

"""
An edge in a connection.
"""
type SchemaVersionChangeEdge {
  """
  The item at the end of the edge
  """
  node: SchemaVersionChange!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type SchemaVersionConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [SchemaVersionEdge!]!

  """
  A list of nodes.
  """
  nodes: [SchemaVersion!]!
}

type SchemaVersionDelta {
  """
  Additions.
  """
  added: Int!

  """
  Removals.
  """
  removed: Int!

  """
  Modifications.
  """
  modified: Int!
}

"""
An edge in a connection.
"""
type SchemaVersionEdge {
  """
  The item at the end of the edge
  """
  node: SchemaVersion!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
A Slack channel returned from the Slack API.
"""
type SlackChannel {
  id: String!
  name: String!
}

type SlackIntegration {
  availableChannels: [SlackChannel!]!
  notifications: [SlackNotification!]!
}

input SlackIntegrationCreateInput {
  tokenId: String!
  graphId: String!
  channelId: String!
  channelName: String!
}

type SlackNotification {
  id: String!
  graphId: String!
  channelName: String!
}

union SlackNotificationCreatePayload = SlackNotification | ProjectDoesNotExistError

union SlackNotificationDeletePayload = Query

type SlugAlreadyExistsError {
  query: Query!
}

type SlugError {
  message: String!
  actual: String!
  expected: String!
  query: Query!
}

type SlugInvalidError {
  query: Query!
}

type SlugSizeCheckError {
  maxLength: Int!
  message: String!
  query: Query!
}

type SlugTooLongError {
  maxLength: Int!
  query: Query!
}

type StripeCard {
  brand: String!
  funding: String!
  expMonth: Int!
  expYear: Int!
  last4: String!
}

type StripeCustomer {
  id: String!
  paymentMethods(
    type: StripePaymentMethodType
    endingBefore: String
    startingAfter: String
    limit: Int
  ): StripePaginatedPaymentMethods!
}

type StripePaginatedPaymentMethods {
  data: [StripePaymentMethod!]!
  hasMore: Boolean!
  nextPage: String
}

type StripePaymentMethod {
  id: String!
  created: DateTime!
  card: StripeCard
  type: StripePaymentMethodType!
}

enum StripePaymentMethodType {
  ACSS_DEBIT
  AFFIRM
  AFTERPAY_CLEARPAY
  ALIPAY
  AU_BECS_DEBIT
  BACS_DEBIT
  BANCONTACT
  BLIK
  BOLETO
  CARD
  CASHAPP
  CUSTOMER_BALANCE
  EPS
  FPX
  GIROPAY
  GRABPAY
  IDEAL
  KLARNA
  KONBINI
  LINK
  OXXO
  P24
  PAYNOW
  PIX
  PROMPTPAY
  SEPA_DEBIT
  SOFORT
  US_BANK_ACCOUNT
  WECHAT_PAY
}

type StripeSetupIntent {
  id: String!
  clientSecret: String!
}

union StripeSetupIntentCreatePayload = StripeSetupIntentCreateSuccess

type StripeSetupIntentCreateSuccess {
  setupIntent: StripeSetupIntent!
  query: Query!
}

type Subgraph {
  name: String!
  url: String!
  schema: String!
  createdAt: DateTime!
  updatedAt: DateTime
}

type SubgraphNameMissingOnFederatedProjectError {
  query: Query!
}

type SubgraphNameProvidedOnSingleProjectError {
  query: Query! @deprecated(reason: "Type renamed to SubgraphNameProvidedOnStandaloneProjectError")
}

type SubgraphNameProvidedOnStandaloneProjectError {
  query: Query!
}

type SubgraphNotFoundError {
  query: Query!
}

type TemplateDoesNotExistError {
  query: Query!
}

enum TimeAggregationGranularity {
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
}

type TimeSeries {
  unit: UnitType!
  data: [TimeSeriesDataPoint!]!
  statistics: TimeSeriesStatistics!
}

type TimeSeriesDataPoint {
  datetime: DateTime!
  value: Int!
}

type TimeSeriesStatistics {
  sum: Int!
}

type TokenDoesNotExistError {
  query: Query!
}

type TokenLimitExceededError {
  query: Query!
}

type TooManyCustomDomainsError {
  query: Query!
}

type TrustedDocument {
  documentId: String!
  documentText: String!
}

input TrustedDocumentInput {
  documentId: String!
  documentText: String!
}

union TrustedDocumentsSubmitPayload =
  | TrustedDocumentsSubmitSuccess
  | ReusedIds
  | ProjectDoesNotExistError
  | OldAccessTokenError

type TrustedDocumentsSubmitSuccess {
  count: Int!
  documents: [TrustedDocument!]!
}

enum UnitType {
  NO_UNIT
  MILLI_SECONDS
  BYTES
}

"""
URL is a String implementing the [URL Standard](http://url.spec.whatwg.org/)
"""
scalar Url

type User implements Node {
  id: ID!
  name: String!
  email: String!
  avatarUrl: String
  createdAt: DateTime!
  organizations(after: String, before: String, first: Int, last: Int): OrganizationConnection!
  organizationMemberships: [Member!]!
  personalAccount: PersonalAccount
  limits: ViewerLimits! @deprecated(reason: "Moved to account level")
}

type ValidationCheckError {
  title: String!
  message: String!
}

type ValueTooLongError {
  query: Query!
}

type ViewerLimits {
  remainingProjects: Int
  totalProjects: Int
}
