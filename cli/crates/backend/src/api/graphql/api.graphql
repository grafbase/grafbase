type AccessToken {
	id: ID!
	name: String!
	accountId: ID
	createdAt: DateTime!
}

type AccessTokenConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [AccessTokenEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [AccessToken!]!
}

input AccessTokenCreateInput {
	name: String!
	accountId: ID
}

union AccessTokenCreatePayload = AccessTokenCreateSuccess | InvalidAccountError | TokenLimitExceededError

type AccessTokenCreateSuccess {
	token: AccessToken!
	jwt: String!
	query: Query!
}

input AccessTokenDeleteInput {
	id: ID!
}

union AccessTokenDeletePayload = AccessTokenDeleteSuccess | TokenDoesNotExistError

type AccessTokenDeleteSuccess {
	deletedId: ID!
	query: Query!
}

"""
An edge in a connection.
"""
type AccessTokenEdge {
	"""
	The item at the end of the edge
	"""
	node: AccessToken!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

interface Account {
	id: ID!
	slug: String!
	name: String!
	createdAt: DateTime!
	status: AccountStatus!
	projects(after: String, before: String, first: Int, last: Int): ProjectConnection!
	projectsCountStatus: ResourceStatus!
	resources: AccountResources!
	usage(filter: AccountResourcesUsageDashboardFilter): DatabaseUsage!
	resourcesUsageDashboard(filter: AccountResourcesUsageDashboardFilter): AccountResourcesUsageDashboardPayload!
}

input AccountCreationValidateInput {
	slug: String!
}

type AccountCreationValidatePayload {
	slugAvailable: Boolean!
}

type AccountDoesNotExistError {
	query: Query!
}

type AccountResources {
	projects: ResourceStatus!
}

type AccountResourcesStatus {
	requestCount: ResourceStatus!
	dbReads: ResourceStatus!
	dbWrites: ResourceStatus!
	dbSize: ResourceStatus!
	buildDuration: ResourceStatus!
	execUnits: ResourceStatus!
}

type AccountResourcesUsage {
	requestCount: TimeSeries!
	dbReads: TimeSeries!
	dbWrites: TimeSeries!
	dbSize: TimeSeries!
	buildDuration: TimeSeries!
	execUnits: TimeSeries!
	granularity: TimeAggregationGranularity!
}

"""
'limit_cycle_choice' is exclusive with all other options. It's the only case
where we'll show account limit status (used/limit)
"""
input AccountResourcesUsageDashboardFilter {
	projectIds: [ID!]
	limitCycleChoice: LimitCycleChoice
	startDate: DateTime
	endDate: DateTime
}

type AccountResourcesUsageDashboardInvalidFilterCombinationError {
	message: String!
	query: Query!
}

union AccountResourcesUsageDashboardPayload = AccountResourcesUsageDashboardSuccess | AccountResourcesUsageDashboardInvalidFilterCombinationError

type AccountResourcesUsageDashboardSuccess {
	periodStart: DateTime!
	periodEnd: DateTime!
	usage: AccountResourcesUsage!
	status: AccountResourcesStatus
}

type AccountStatus {
	isEnabled: Boolean!
	inArrearsCause: InArrearsCause
	hasExceededLimits: Boolean!
	isHobbyPlanEnforced: Boolean!
}

type AlreadyMemberError {
	query: Query!
}

type ArchiveFileSizeLimitExceededError {
	query: Query!
	limit: Int!
}


type Branch {
	id: ID!
	name: String!
	domains: [String!]!
	latestDeployment: Deployment
	activeDeployment: Deployment
	deployments(after: String, before: String, first: Int, last: Int): DeploymentConnection!
	project: Project!
	environment: BranchEnvironment!
}

type BranchConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [BranchEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Branch!]!
}

"""
An edge in a connection.
"""
type BranchEdge {
	"""
	The item at the end of the edge
	"""
	node: Branch!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

enum BranchEnvironment {
	PREVIEW
	PRODUCTION
}

union BranchMetricsPayload = BranchMetricsSuccess | ProjectDoesNotExistError

type BranchMetricsSuccess {
	latency: Distribution!
	request: Distribution!
}

type CurrentPlanLimitReachedError {
	max: Int!
	query: Query!
}

type CustomDomain {
	hostnameVerificationStatus: CustomDomainStatus!
	hostnameVerificationTxtName: String
	hostnameVerificationTxtValue: String
	name: String!
	sslVerificationCnameName: String
	sslVerificationCnameValue: String
	sslVerificationStatus: CustomDomainStatus!
}

type CustomDomainAlreadyExists {
	query: Query!
}

input CustomDomainCreateInput {
	projectId: ID!
	name: String!
}

union CustomDomainCreatePayload = CustomDomainCreateSuccess | ProjectDoesNotExistError | CustomDomainAlreadyExists | ProjectNotDeployed

type CustomDomainCreateSuccess {
	domain: CustomDomain!
	query: Query!
}

input CustomDomainDeleteInput {
	projectId: ID!
	name: String!
}

union CustomDomainDeletePayload = CustomDomainDeleteSuccess | CustomDomainDoesNotExistError

type CustomDomainDeleteSuccess {
	name: String!
}

type CustomDomainDoesNotExistError {
	query: Query!
}

enum CustomDomainStatus {
	ACTIVE
	PENDING
	ERROR
}

type DailyDeploymentCountLimitExceededError {
	query: Query!
	limit: Int!
}

type DatabaseRegion {
	name: String!
	city: String!
	countryCode: String!
	continent: String!
}

enum DatabaseRegionChangeStatus {
	IN_PROGRESS
	COMPLETED
}

type DatabaseUsage {
	requestCount: Distribution!
	dbReads: Distribution!
	dbWrites: Distribution!
	dbSize: Distribution!
	buildDuration: Distribution!
	execUnits: Distribution!
	granularity: DatabaseUsageGranularity!
}

input DatabaseUsageFilter {
	environment: BranchEnvironment
	startDate: DateTime
	endDate: DateTime
}

enum DatabaseUsageGranularity {
	HOURLY
	DAILY
	WEEKLY
	MONTHLY
}

"""
RFC3339 formatted date in the UTC time zone denoted by letter 'Z'
"""
scalar DateTime

"""
Deployment
"""
type Deployment {
	id: ID!
	commit: GitCommit
	branch: Branch!
	createdAt: DateTime!
	startedAt: DateTime
	finishedAt: DateTime
	"""
	The duration of the deployment in milliseconds.
	"""
	duration: Int
	status: DeploymentStatus!
	logEntries: [DeploymentLogEntry!]!
	project: Project!
	schema: String
	diffAgainstPreviousBranchDeployment: String
	diffAgainstLatestProductionDeployment: String
}

type DeploymentConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [DeploymentEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Deployment!]!
}

input DeploymentCreateInput {
	projectId: ID!
	archiveFileSize: Int!
	branch: String
}

union DeploymentCreatePayload = DeploymentCreateSuccess | ProjectDoesNotExistError | ArchiveFileSizeLimitExceededError | DailyDeploymentCountLimitExceededError

type DeploymentCreateSuccess {
	deployment: Deployment!
	presignedUrl: String!
	query: Query!
}

"""
An edge in a connection.
"""
type DeploymentEdge {
	"""
	The item at the end of the edge
	"""
	node: Deployment!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

input DeploymentFilter {
	branch: String
	statuses: [DeploymentStatus!]
}

type DeploymentLogEntry {
	createdAt: DateTime!
	message: String!
	level: DeploymentLogLevel!
}

enum DeploymentLogLevel {
	ERROR
	INFO
}

enum DeploymentStatus {
	QUEUED
	IN_PROGRESS
	SUCCEEDED
	FAILED
}

type DisabledAccountError {
	query: Query!
}

type Distribution {
	unit: UnitType!
	values: [DistributionValue!]!
}

type DistributionValue {
	bucket: DateTime!
	value: Int!
}

type DuplicateDatabaseRegionsError {
	duplicates: [String!]!
	query: Query!
}

"""
Implement the Duration scalar

The input/output is a string in ISO8601 format.
"""
scalar Duration

type EmptyDatabaseRegionsError {
	query: Query!
}

type EnvironmentVariable {
	id: ID!
	name: String!
	value: String!
	createdAt: DateTime!
	updatedAt: DateTime!
	environments: [BranchEnvironment!]!
	branches: [String!]
}

type EnvironmentVariableConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [EnvironmentVariableEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [EnvironmentVariable!]!
}

type EnvironmentVariableCountLimitExceededError {
	query: Query!
}

input EnvironmentVariableCreateInput {
	projectId: ID!
	"""
	Must not be already assigned.
	"""
	name: String!
	value: String!
	environments: [BranchEnvironment!]!
}

union EnvironmentVariableCreatePayload = EnvironmentVariableCreateSuccess | NameAlreadyExistsError | NameTooLongError | NameContainsInvalidCharactersError | ValueTooLongError | ReservedPrefixError | ProjectDoesNotExistError

type EnvironmentVariableCreateSuccess {
	environmentVariable: EnvironmentVariable!
	query: Query!
}

input EnvironmentVariableDeleteInput {
	id: ID!
}

union EnvironmentVariableDeletePayload = EnvironmentVariableDeleteSuccess | EnvironmentVariableDoesNotExistError

type EnvironmentVariableDeleteSuccess {
	deletedId: ID!
	query: Query!
}

type EnvironmentVariableDoesNotExistError {
	query: Query!
}

"""
An edge in a connection.
"""
type EnvironmentVariableEdge {
	"""
	The item at the end of the edge
	"""
	node: EnvironmentVariable!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

input EnvironmentVariableSpecification {
	name: String!
	value: String!
}

input EnvironmentVariableUpdateInput {
	id: ID!
	name: String
	value: String
	environments: [BranchEnvironment!]
}

union EnvironmentVariableUpdatePayload = EnvironmentVariableUpdateSuccess | EnvironmentVariableDoesNotExistError | NameAlreadyExistsError | NameTooLongError | NameContainsInvalidCharactersError | ValueTooLongError | ReservedPrefixError

type EnvironmentVariableUpdateSuccess {
	environmentVariable: EnvironmentVariable!
	query: Query!
}


enum FunctionKind {
	AUTHORIZER
	RESOLVER
}

type FunctionLogEvent implements LogEvent {
	id: String!
	branch: String!
	environment: BranchEnvironment!
	deploymentId: ID!
	createdAt: DateTime!
	functionKind: FunctionKind!
	functionName: String!
	region: String!
	logLevel: LogLevel!
	url: String
	message: String!
}

type GatewayRequestLogEvent implements LogEvent {
	id: String!
	branch: String!
	environment: BranchEnvironment!
	deploymentId: ID!
	createdAt: DateTime!
	region: String!
	logLevel: LogLevel!
	httpMethod: String!
	httpStatus: Int!
	url: String!
	operation: GatewayRequestLogEventOperation
	duration: Int!
	message: String!
}

type GatewayRequestLogEventOperation {
	name: String
	type: OperationType!
}

type GitAccount {
	provider: GitProvider!
	id: ID!
	slug: String!
	type: GitAccountType!
	"""
	Date when the app was authorized to access this account
	"""
	connectedAt: DateTime!
}

enum GitAccountType {
	ORGANIZATION
	PERSONAL
}

union GitAccountsPayload = GitAccountsSuccess | GitHubAuthorizationError

type GitAccountsSuccess {
	accounts: [GitAccount!]!
	query: Query!
}

type GitCommit {
	sha: String!
	message: String!
	author: String
	authorAvatarUrl: String
}

type GitHubAuthorizationError {
	query: Query!
}

enum GitProvider {
	GITHUB
}

type GitRepository {
	provider: GitProvider!
	id: String!
	owner: String!
	slug: String!
	url: String!
	defaultBranch: String
	private: Boolean!
	updatedAt: DateTime!
	branches: [String!]!
}

type GithubInstallationInsufficientPermissionsError {
	query: Query!
}

type HasAlreadyPaymentMethodError {
	query: Query!
}


enum InArrearsCause {
	NEVER_PAID
	UNPAID_INVOICE
}


type InvalidAccountError {
	query: Query!
}

type InvalidDatabaseRegionsError {
	invalid: [String!]!
	query: Query!
}

type InvalidEnvironmentVariableError {
	variableName: String!
	error: InvalidEnvironmentVariableErrorType!
}

enum InvalidEnvironmentVariableErrorType {
	NAME_TOO_LONG
	NAME_CONTAINS_INVALID_CHARACTERS
	VALUE_TOO_LONG
	RESERVED_PREFIX
	DUPLICATE
}

type InvalidEnvironmentVariablesError {
	errors: [InvalidEnvironmentVariableError!]!
}

type Invite {
	id: ID!
	role: MemberRole!
	email: String!
	invitedBy: User!
	lastRenewedAt: DateTime!
	status: InviteStatus!
	createdAt: DateTime!
	organization: Organization!
}

input InviteAcceptInput {
	id: ID!
}

union InviteAcceptPayload = InviteAcceptSuccess | InviteDoesNotExistError | AlreadyMemberError

type InviteAcceptSuccess {
	member: Member!
	query: Query!
}

input InviteCancelInput {
	id: ID!
}

union InviteCancelPayload = InviteCancelSuccess | InviteDoesNotExistError | NotAllowedToCancelInvitesError

type InviteCancelSuccess {
	id: ID!
	query: Query!
}

type InviteConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [InviteEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Invite!]!
}

input InviteDeclineInput {
	id: ID!
}

union InviteDeclinePayload = InviteDeclineSuccess | InviteDoesNotExistError

type InviteDeclineSuccess {
	id: ID!
	query: Query!
}

type InviteDoesNotExistError {
	query: Query!
}

"""
An edge in a connection.
"""
type InviteEdge {
	"""
	The item at the end of the edge
	"""
	node: Invite!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

input InviteSendInput {
	organizationId: ID!
	email: String!
	role: MemberRole!
}

union InviteSendPayload = InviteSendSuccess | OrganizationDoesNotExistError | NotAllowedToSendInvitesError

type InviteSendSuccess {
	invite: Invite!
	query: Query!
}

enum InviteStatus {
	PENDING
	EXPIRED
}

type KeyDoesNotExistError {
	query: Query!
}

type KeyLimitExceededError {
	query: Query!
}

"""
Users can select the previous/current "limit cycle" which defines the cycle on which limits
applies. For hobby it's monthly starting the first of each month and for pro it matches the
billing cycle.
"""
enum LimitCycleChoice {
	CURRENT
	PREVIOUS
}

interface LogEvent {
	id: String!
	createdAt: DateTime!
	region: String!
	logLevel: LogLevel!
	deploymentId: ID!
	branch: String!
	environment: BranchEnvironment!
	message: String!
}

type LogEventConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [LogEventEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [LogEvent!]!
}

"""
An edge in a connection.
"""
type LogEventEdge {
	"""
	The item at the end of the edge
	"""
	node: LogEvent!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

input LogEventFilter {
	query: String
	branch: String
	from: DateTime
	to: DateTime
	region: [String!]
	logLevel: [LogLevel!]
}

enum LogLevel {
	DEBUG
	INFO
	WARN
	ERROR
}

type Member {
	id: ID!
	role: MemberRole!
	createdAt: DateTime!
	account: Account!
	user: User!
}

type MemberConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [MemberEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Member!]!
}

input MemberDeleteInput {
	id: ID!
}

type MemberDeletePayload {
	deletedMemberId: ID!
	query: Query!
}

"""
An edge in a connection.
"""
type MemberEdge {
	"""
	The item at the end of the edge
	"""
	node: Member!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

enum MemberRole {
	OWNER
	MEMBER
}

input MemberUpdateInput {
	id: ID!
	role: MemberRole
}

type MemberUpdatePayload {
	member: Member!
	query: Query!
}

type MissingStripeCustomerError {
	query: Query!
}

type MonthlyLimits {
	reads: Int
	writes: Int
	apiRequests: Int
	size: Int
}

type MustLeaveAtLeastOneKeyForEnvironmentError {
	query: Query!
}

type Mutation {
	"""
	Create a new access token.
	"""
	accessTokenCreate(input: AccessTokenCreateInput!): AccessTokenCreatePayload!
	"""
	Delete a given access token.
	"""
	accessTokenDelete(input: AccessTokenDeleteInput!): AccessTokenDeletePayload!
	"""
	Create new organization account owned by the current user. Slug must be unique.
	"""
	organizationCreate(input: OrganizationCreateInput!): OrganizationCreatePayload!
	organizationSlugUpdate(input: OrganizationSlugUpdateInput!): OrganizationSlugUpdatePayload!
	personalAccountSlugUpdate(input: PersonalAccountSlugUpdateInput!): PersonalAccountSlugUpdatePayload!
	organizationPaymentMethodReplace(accountId: ID!, stripePaymentMethodId: String!): OrganizationPaymentMethodReplacePayload!
	organizationSetupPaymentMethod(accountId: ID!, stripePaymentMethodId: String!): OrganizationSetupPaymentMethod!
	organizationUpdate(input: OrganizationUpdateInput!): OrganizationUpdatePayload!
	personalAccountUpdate(input: PersonalAccountUpdateInput!): PersonalAccountUpdatePayload!
	personalAccountDelete: PersonalAccountDeletePayload!
	organizationDelete(input: OrganizationDeleteInput!): OrganizationDeletePayload!
	"""
	Add a new custom domain.
	"""
	customDomainCreate(input: CustomDomainCreateInput!): CustomDomainCreatePayload!
	"""
	Delete a custom hostname token.
	"""
	customDomainDelete(input: CustomDomainDeleteInput!): CustomDomainDeletePayload!
	"""
	Create a new deployment for an existing project.
	"""
	deploymentCreate(input: DeploymentCreateInput!): DeploymentCreatePayload!
	"""
	Create a new environment variable.
	"""
	environmentVariableCreate(input: EnvironmentVariableCreateInput!): EnvironmentVariableCreatePayload!
	"""
	Update an environment variable.
	"""
	environmentVariableUpdate(input: EnvironmentVariableUpdateInput!): EnvironmentVariableUpdatePayload!
	"""
	Delete an environment variable.
	"""
	environmentVariableDelete(input: EnvironmentVariableDeleteInput!): EnvironmentVariableDeletePayload!
	inviteSend(input: InviteSendInput!): InviteSendPayload!
	inviteCancel(input: InviteCancelInput!): InviteCancelPayload!
	inviteAccept(input: InviteAcceptInput!): InviteAcceptPayload!
	inviteDecline(input: InviteDeclineInput!): InviteDeclinePayload!
	"""
	Update role of an organization member
	"""
	memberUpdate(input: MemberUpdateInput!): MemberUpdatePayload!
	"""
	Remove member from an organization
	"""
	memberDelete(input: MemberDeleteInput!): MemberDeletePayload!
	"""
	Create a new project API key.
	"""
	projectApiKeyCreate(input: ProjectApiKeyCreateInput!): ProjectApiKeyCreatePayload!
	"""
	Update a given API key with a new name.
	"""
	projectApiKeyUpdate(input: ProjectApiKeyUpdateInput!): ProjectApiKeyUpdatePayload!
	"""
	Delete a given API key.
	"""
	projectApiKeyDelete(input: ProjectApiKeyDeleteInput!): ProjectApiKeyDeletePayload!
	"""
	Create a new project without any source for an initial deployment.
	"""
	projectCreate(input: ProjectCreateInput!): ProjectCreatePayload!
	"""
	Create a new project from a GitHub repository.
	"""
	projectCreateFromSchema(input: ProjectCreateFromSchemaInput!): ProjectCreateFromSchemaPayload!
	"""
	Create a new project from a GitHub repository.
	"""
	projectCreateFromRepository(input: ProjectCreateFromRepositoryInput!): ProjectCreateFromRepositoryPayload!
	"""
	Create a new project from a template in a newly created GitHub repository.
	"""
	projectCreateFromTemplate(input: ProjectCreateFromTemplateInput!): ProjectCreateFromTemplatePayload!
	projectUpdate(input: ProjectUpdateInput!): ProjectUpdatePayload!
	projectDelete(input: ProjectDeleteInput!): ProjectDeletePayload!
	stripeSetupIntentCreate: StripeSetupIntentCreatePayload!
}

type NameAlreadyExistsError {
	query: Query!
}

type NameContainsInvalidCharactersError {
	query: Query!
}

type NameSizeCheckError {
	maxLength: Int!
	message: String!
	query: Query!
}

type NameTooLongError {
	query: Query!
}

type NotAllowedError {
	query: Query!
}

type NotAllowedToCancelInvitesError {
	query: Query!
}

type NotAllowedToDeleteOrganizationError {
	query: Query!
}

type NotAllowedToSendInvitesError {
	query: Query!
}

type NotAllowedToSlugUpdateError {
	query: Query!
}

type NotAllowedToUpdateOrganizationError {
	query: Query!
}

enum OperationType {
	QUERY
	MUTATION
	SUBSCRIPTION
}

type OrbBillingAddress {
	city: String
	country: String
	line1: String
	line2: String
	postalCode: String
	state: String
}

input OrbBillingAddressInput {
	city: String
	country: String
	line1: String
	line2: String
	postalCode: String
	state: String
}

type OrbCustomer {
	id: String!
	name: String!
	email: String!
	taxId: OrbTaxId
	billingAddress: OrbBillingAddress
	subscriptions(cursor: String): OrbPaginatedSubscriptions!
}

input OrbCustomerUpdateInput {
	name: String
	email: String
	billingAddress: OrbBillingAddressInput
	taxId: OrbTaxIdInput
}

type OrbInvoice {
	id: String!
	dueDate: DateTime!
	invoiceDate: DateTime!
	status: OrbInvoiceStatus!
	total: String!
	currency: String!
	lineItems: [OrbInvoiceLineItem!]!
	invoicePdf: Url!
	invoiceNumber: String!
}

type OrbInvoiceLineItem {
	id: String!
	name: String!
	quantity: Float!
	amount: String!
	price: OrbPrice!
	startDate: DateTime!
	endDate: DateTime!
}

enum OrbInvoiceStatus {
	ISSUED
	PAID
	SYNCED
	VOID
	DRAFT
}

type OrbPaginatedInvoices {
	data: [OrbInvoice!]!
	paginationMetadata: OrbPaginationMetadata!
}

type OrbPaginatedSubscriptions {
	data: [OrbSubscription!]!
	paginationMetadata: OrbPaginationMetadata!
}

type OrbPaginationMetadata {
	nextCursor: String
}

type OrbPlan {
	externalPlanId: String
}

type OrbPrice {
	currency: String!
	modelType: OrbPriceModelType!
	unitConfig: OrbPriceUnitConfig
	packageConfig: OrbPricePackageConfig
}

enum OrbPriceModelType {
	UNIT
	TIERED
	BULK
	PACKAGE
	BPS
	TIERED_BPS
	BULK_BPS
	MATRIX
}

type OrbPricePackageConfig {
	packageAmount: String!
	packageSize: Float!
}

type OrbPriceUnitConfig {
	unitAmount: String!
}

type OrbSubscription {
	id: String!
	status: OrbSubscriptionStatus!
	plan: OrbPlan!
	currentBillingPeriodStartDate: DateTime
	currentBillingPeriodEndDate: DateTime
	endDate: DateTime
	invoices(cursor: String): OrbPaginatedInvoices!
	upcomingInvoice: OrbUpcomingInvoice
}

enum OrbSubscriptionStatus {
	ACTIVE
	ENDED
	UPCOMING
}

type OrbTaxId {
	type: OrbTaxIdType!
	value: String!
	country: String!
}

input OrbTaxIdInput {
	type: OrbTaxIdType!
	value: String!
	country: String!
}

enum OrbTaxIdType {
	AE_TRN
	AU_ABN
	AU_ARN
	BG_UIC
	BR_CNPJ
	BR_CPF
	CA_BN
	CA_GST_HST
	CA_PST_BC
	CA_PST_MB
	CA_PST_SK
	CA_QST
	CH_VAT
	CL_TIN
	EG_TIN
	ES_CIF
	EU_OSS_VAT
	EU_VAT
	GB_VAT
	GE_VAT
	HK_BR
	HU_TIN
	ID_NPWP
	IL_VAT
	IN_GST
	IS_VAT
	JP_CN
	JP_RN
	JP_TRN
	KE_PIN
	KR_BRN
	LI_UID
	MX_RFC
	MY_FRP
	MY_ITN
	MY_SST
	NO_VAT
	NZ_GST
	PH_TIN
	RU_INN
	RU_KPP
	SA_VAT
	SG_GST
	SG_UEN
	SI_TIN
	TH_VAT
	TR_TIN
	TW_VAT
	UA_VAT
	US_EIN
	ZA_VAT
}

type OrbUpcomingInvoice {
	targetDate: DateTime!
	subtotal: String!
	currency: String!
	lineItems: [OrbUpcomingInvoiceLineItem!]!
}

type OrbUpcomingInvoiceLineItem {
	name: String!
	quantity: Float!
	amount: String!
	startDate: DateTime!
	endDate: DateTime!
	price: OrbPrice!
}

type OrbValidationError {
	errors: [String!]!
	query: Query!
}

type Organization implements Account {
	id: ID!
	slug: String!
	name: String!
	createdAt: DateTime!
	status: AccountStatus!
	stripeCustomer: StripeCustomer
	orbCustomer: OrbCustomer
	orbActiveSubscription: OrbSubscription
	projects(after: String, before: String, first: Int, last: Int): ProjectConnection!
	invites(after: String, before: String, first: Int, last: Int): InviteConnection!
	members(after: String, before: String, first: Int, last: Int): MemberConnection!
	projectsCountStatus: ResourceStatus!
	usage(filter: AccountResourcesUsageDashboardFilter): DatabaseUsage! @deprecated(reason: "Use resources_usage_dashboard")
	resourcesUsageDashboard(filter: AccountResourcesUsageDashboardFilter): AccountResourcesUsageDashboardPayload!
	resources: AccountResources! @deprecated(reason: "Not relevant for organizations")
}

type OrganizationConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [OrganizationEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Organization!]!
}

input OrganizationCreateInput {
	slug: String!
	name: String!
	email: String
	stripePaymentMethodId: String!
}

union OrganizationCreatePayload = OrganizationCreateSuccess | SlugError | SlugSizeCheckError | NameSizeCheckError | ReservedSlugsCheckError | SlugAlreadyExistsError

type OrganizationCreateSuccess {
	organization: Organization!
	member: Member!
	query: Query!
}

input OrganizationDeleteInput {
	id: ID!
}

union OrganizationDeletePayload = OrganizationDeleteSuccess | OrganizationDoesNotExistError | NotAllowedToDeleteOrganizationError

type OrganizationDeleteSuccess {
	deletedId: ID!
	query: Query!
}

type OrganizationDoesNotExistError {
	query: Query!
}

"""
An edge in a connection.
"""
type OrganizationEdge {
	"""
	The item at the end of the edge
	"""
	node: Organization!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

type OrganizationOwnershipNotTransferredError {
	query: Query!
}

union OrganizationPaymentMethodReplacePayload = OrganizationSuccessfulUpdate | MissingStripeCustomerError | OrganizationDoesNotExistError | NotAllowedError

union OrganizationSetupPaymentMethod = OrganizationUpgradeToProSuccess | HasAlreadyPaymentMethodError | OrganizationDoesNotExistError | NotAllowedError

input OrganizationSlugUpdateInput {
	id: ID!
	slug: String!
}

union OrganizationSlugUpdatePayload = OrganizationSlugUpdateSuccess | SlugError | SlugSizeCheckError | ReservedSlugsCheckError | SlugAlreadyExistsError | OrganizationDoesNotExistError | NotAllowedToSlugUpdateError

type OrganizationSlugUpdateSuccess {
	organization: Organization!
	query: Query!
}

type OrganizationSuccessfulUpdate {
	organization: Organization!
	query: Query!
}

input OrganizationUpdateInput {
	id: ID!
	name: String
	orbCustomer: OrbCustomerUpdateInput
}

union OrganizationUpdatePayload = OrganizationUpdateSuccess | OrganizationDoesNotExistError | NameSizeCheckError | NotAllowedToUpdateOrganizationError | OrbValidationError

type OrganizationUpdateSuccess {
	organization: Organization!
	query: Query!
}

type OrganizationUpgradeToProSuccess {
	organization: Organization!
	query: Query!
}

"""
Information about pagination in a connection
"""
type PageInfo {
	"""
	When paginating backwards, are there more items?
	"""
	hasPreviousPage: Boolean!
	"""
	When paginating forwards, are there more items?
	"""
	hasNextPage: Boolean!
	"""
	When paginating backwards, the cursor to continue.
	"""
	startCursor: String
	"""
	When paginating forwards, the cursor to continue.
	"""
	endCursor: String
}

type PersonalAccount implements Account {
	id: ID!
	slug: String!
	name: String!
	createdAt: DateTime!
	status: AccountStatus!
	projects(after: String, before: String, first: Int, last: Int): ProjectConnection!
	projectsCountStatus: ResourceStatus!
	usage(filter: AccountResourcesUsageDashboardFilter): DatabaseUsage! @deprecated(reason: "Use resources_usage_dashboard")
	resourcesUsageDashboard(filter: AccountResourcesUsageDashboardFilter): AccountResourcesUsageDashboardPayload!
	resources: AccountResources! @deprecated(reason: "use projects_count_status")
}

union PersonalAccountDeletePayload = PersonalAccountDeleteSuccess | OrganizationOwnershipNotTransferredError

type PersonalAccountDeleteSuccess {
	deletedId: ID!
	query: Query!
}

input PersonalAccountSlugUpdateInput {
	slug: String!
}

union PersonalAccountSlugUpdatePayload = PersonalAccountSlugUpdateSuccess | SlugError | SlugSizeCheckError | ReservedSlugsCheckError | SlugAlreadyExistsError

type PersonalAccountSlugUpdateSuccess {
	query: Query!
}

input PersonalAccountUpdateInput {
	name: String!
}

union PersonalAccountUpdatePayload = PersonalAccountUpdateSuccess | NameSizeCheckError

type PersonalAccountUpdateSuccess {
	query: Query!
}

type Project {
	id: ID!
	accountSlug: String!
	slug: String!
	createdAt: DateTime!
	repository: GitRepository
	branches(after: String, before: String, first: Int, last: Int): BranchConnection!
	apiKeys(after: String, before: String, first: Int, last: Int): ProjectApiKeyConnection!
	productionBranch: Branch!
	environmentVariables(after: String, before: String, first: Int, last: Int): EnvironmentVariableConnection!
	deployments(after: String, before: String, first: Int, last: Int, filter: DeploymentFilter): DeploymentConnection!
	databaseRegions: [DatabaseRegion!]!
	usage(filter: DatabaseUsageFilter): DatabaseUsage!
	plan: ProjectPlan!
	status: ProjectStatus!
	databaseRegionChangeStatus: DatabaseRegionChangeStatus!
	customDomains: [String!]!
	requestAnalytics(filter: ProjectRequestAnalyticsFilter!): RequestAnalytics!
	logEvents(first: Int, after: String, last: Int, before: String, filter: LogEventFilter!): LogEventConnection!
}

type ProjectApiKey {
	id: ID!
	key: String!
	environment: BranchEnvironment!
	createdAt: DateTime!
	name: String!
}

type ProjectApiKeyConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [ProjectApiKeyEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [ProjectApiKey!]!
}

input ProjectApiKeyCreateInput {
	projectId: ID!
	environment: BranchEnvironment!
	name: String!
}

union ProjectApiKeyCreatePayload = ProjectApiKeyCreateSuccess | KeyLimitExceededError | ProjectDoesNotExistError

type ProjectApiKeyCreateSuccess {
	apiKey: ProjectApiKey!
	query: Query!
}

input ProjectApiKeyDeleteInput {
	id: ID!
}

union ProjectApiKeyDeletePayload = ProjectApiKeyDeleteSuccess | KeyDoesNotExistError | MustLeaveAtLeastOneKeyForEnvironmentError

type ProjectApiKeyDeleteSuccess {
	deletedId: ID!
	query: Query!
}

"""
An edge in a connection.
"""
type ProjectApiKeyEdge {
	"""
	The item at the end of the edge
	"""
	node: ProjectApiKey!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

input ProjectApiKeyUpdateInput {
	id: ID!
	name: String!
}

union ProjectApiKeyUpdatePayload = ProjectApiKeyUpdateSuccess | KeyDoesNotExistError

type ProjectApiKeyUpdateSuccess {
	query: Query!
}

type ProjectConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [ProjectEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Project!]!
}

input ProjectCreateFromRepositoryInput {
	accountId: ID!
	projectSlug: String!
	gitRepoUrl: Url!
	gitAccountId: String!
	productionBranch: String!
	databaseRegions: [String!]! = []
	environmentVariables: [EnvironmentVariableSpecification!]! = []
}

union ProjectCreateFromRepositoryPayload = ProjectCreateFromRepositorySuccess | SlugAlreadyExistsError | DisabledAccountError | SlugInvalidError | SlugTooLongError | RepositoryContainsNoBranchesError | AccountDoesNotExistError | CurrentPlanLimitReachedError | EmptyDatabaseRegionsError | DuplicateDatabaseRegionsError | InvalidDatabaseRegionsError | EnvironmentVariableCountLimitExceededError | InvalidEnvironmentVariablesError

type ProjectCreateFromRepositorySuccess {
	project: Project!
	query: Query!
}

input ProjectCreateFromSchemaInput {
	accountId: ID!
	projectSlug: String!
	schema: String!
	databaseRegions: [String!]! = []
	environmentVariables: [EnvironmentVariableSpecification!]! = []
}

union ProjectCreateFromSchemaPayload = ProjectCreateFromSchemaSuccess | SlugAlreadyExistsError | DisabledAccountError | SlugInvalidError | SlugTooLongError | AccountDoesNotExistError | CurrentPlanLimitReachedError | EmptyDatabaseRegionsError | DuplicateDatabaseRegionsError | InvalidDatabaseRegionsError | EnvironmentVariableCountLimitExceededError | InvalidEnvironmentVariablesError

type ProjectCreateFromSchemaSuccess {
	project: Project!
	query: Query!
}

input ProjectCreateFromTemplateInput {
	accountId: ID!
	projectSlug: String!
	templateGitUrl: Url!
	gitAccountId: String!
	repoSlug: String!
	repoPrivate: Boolean!
	databaseRegions: [String!]! = []
	environmentVariables: [EnvironmentVariableSpecification!]! = []
}

union ProjectCreateFromTemplatePayload = ProjectCreateFromTemplateSuccess | SlugAlreadyExistsError | DisabledAccountError | SlugInvalidError | SlugTooLongError | RepositorySlugInUseError | TemplateDoesNotExistError | AccountDoesNotExistError | CurrentPlanLimitReachedError | EmptyDatabaseRegionsError | DuplicateDatabaseRegionsError | InvalidDatabaseRegionsError | EnvironmentVariableCountLimitExceededError | InvalidEnvironmentVariablesError | GithubInstallationInsufficientPermissionsError

type ProjectCreateFromTemplateSuccess {
	project: Project!
	query: Query!
}

input ProjectCreateInput {
	accountId: ID!
	projectSlug: String!
	databaseRegions: [String!]!
	environmentVariables: [EnvironmentVariableSpecification!]! = []
}

union ProjectCreatePayload = ProjectCreateSuccess | SlugAlreadyExistsError | DisabledAccountError | SlugInvalidError | SlugTooLongError | AccountDoesNotExistError | CurrentPlanLimitReachedError | EmptyDatabaseRegionsError | DuplicateDatabaseRegionsError | InvalidDatabaseRegionsError | EnvironmentVariableCountLimitExceededError | InvalidEnvironmentVariablesError

type ProjectCreateSuccess {
	project: Project!
	query: Query!
}

input ProjectDeleteInput {
	id: ID!
}

union ProjectDeletePayload = ProjectDeleteSuccess | ProjectDoesNotExistError

type ProjectDeleteSuccess {
	query: Query!
}

type ProjectDoesNotExistError {
	query: Query!
}

"""
An edge in a connection.
"""
type ProjectEdge {
	"""
	The item at the end of the edge
	"""
	node: Project!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

type ProjectNotDeployed {
	query: Query!
}

type ProjectPlan {
	name: String!
	monthlyLimits: MonthlyLimits!
}

input ProjectRequestAnalyticsFilter {
	branch: String = null
	period: ProjectRequestAnalyticsPeriod!
	now: DateTime!
	graphqlOperation: String
}

enum ProjectRequestAnalyticsPeriod {
	LAST_HOUR
	LAST_24_HOURS
	LAST_7_DAYS
}

enum ProjectStatus {
	ACTIVE
	INACTIVE
}

input ProjectUpdateInput {
	id: ID!
	projectSlug: String
	productionBranch: String
}

union ProjectUpdatePayload = ProjectUpdateSuccess | ProjectDoesNotExistError | SlugAlreadyExistsError | SlugInvalidError | SlugTooLongError

type ProjectUpdateSuccess {
	project: Project!
	query: Query!
}

type Query {
	accessTokens(after: String, before: String, first: Int, last: Int): AccessTokenConnection!
	accountBySlug(
		"""
		slug of the account
		"""
		slug: String!
	): Account
	accountCreationValidate(input: AccountCreationValidateInput!): AccountCreationValidatePayload!
	metricsByBranch(accountSlug: String!, projectSlug: String!, branch: String!, startDate: DateTime!, endDate: DateTime!): BranchMetricsPayload!
	"""
	Get branch by account slug, project slug and the name of the branch.
	"""
	branch(
		"""
		slug of the account
		"""
		accountSlug: String!,
		"""
		slug of the project
		"""
		projectSlug: String!,
		"""
		name of the branch
		"""
		name: String!
	): Branch
	"""
	Get branch by domain.
	"""
	branchByDomain(
		"""
		domain
		"""
		domain: String!
	): Branch
	"""
	Get custom domain by project id and name.
	"""
	customDomainByName(
		"""
		id of the project
		"""
		projectId: ID!,
		"""
		name of the domain
		"""
		name: String!
	): CustomDomain
	"""
	Get all database regions available for replication.
	"""
	databaseRegions: [DatabaseRegion!]!
	closestDatabaseRegion: DatabaseRegion
	"""
	Get deployment by ID.
	"""
	deployment(
		"""
		ID of the deployment
		"""
		id: ID!
	): Deployment
	"""
	Return a list of git accounts accessible by the current user sorted by the creation date.
	"""
	gitAccounts(provider: GitProvider!): GitAccountsPayload!
	"""
	Return a list of git repositories accessible by the current user, sorted by updatedAt.
	With `query` specified, the list will include up to 10 repos matching the query.
	Without `query`, the list will include the 10 most recently updated repos.
	"""
	gitRepos(provider: GitProvider!, gitAccountId: String!, query: String): [GitRepository!]!
	"""
	Returns details about a specific git repository identified by its URL.
	"""
	gitRepoByUrl(url: Url!): GitRepository!
	"""
	Returns the contents of the `schema.graphql` file located in a particular branch of a repository idenitifed by its URL.
	"""
	schema(url: Url!, branch: String!): String
	invite(id: ID!): Invite
	"""
	Get project by account slug and slug of the project itself.
	"""
	projectByAccountSlug(
		"""
		slug of the account
		"""
		accountSlug: String!,
		"""
		slug of the project
		"""
		projectSlug: String!
	): Project
	"""
	Get project by ID.
	"""
	projectById(
		"""
		ID of the project
		"""
		id: ID!
	): Project
	"""
	Give the actual connected user.
	"""
	viewer: User
}

type RepositoryContainsNoBranchesError {
	query: Query!
}

type RepositorySlugInUseError {
	query: Query!
}

type RequestAnalytics {
	timeSeries: RequestMetricsTimeSeries!
	metrics: RequestMetrics!
	periodStart: DateTime!
	periodEnd: DateTime!
}

type RequestLogEvent implements LogEvent {
	id: String!
	branch: String!
	environment: BranchEnvironment!
	deploymentId: ID!
	createdAt: DateTime!
	region: String!
	logLevel: LogLevel!
	url: String!
	httpMethod: String!
	httpStatus: Int!
	duration: Int!
	message: String!
}

type RequestMetrics {
	requestCount: Int!
	cacheableRequestCount: Int!
	cacheHitCount: Int!
	cacheMissCount: Int!
	cachePassCount: Int!
	error4XxCount: Int!
	error5XxCount: Int!
	errorGraphqlCount: Int!
	latencyMsP95: Int
	latencyMsP99: Int
}

type RequestMetricsTimeSeries {
	data: [RequestMetricsTimeSeriesDataPoint!]!
	aggregationStep: Duration!
}

type RequestMetricsTimeSeriesDataPoint {
	dateTime: DateTime!
	requestCount: Int!
	cacheableRequestCount: Int!
	cacheHitCount: Int!
	cacheMissCount: Int!
	cachePassCount: Int!
	error4XxCount: Int!
	error5XxCount: Int!
	errorGraphqlCount: Int!
	latencyMsP95: Int
	latencyMsP99: Int
}

type ReservedPrefixError {
	query: Query!
}

type ReservedSlugsCheckError {
	message: String!
	query: Query!
}

type ResourceStatus {
	unit: UnitType!
	used: Int!
	limit: Int
	remaining: Int
	percentage: Float
}

type SlugAlreadyExistsError {
	query: Query!
}

type SlugError {
	message: String!
	actual: String!
	expected: String!
	query: Query!
}

type SlugInvalidError {
	query: Query!
}

type SlugSizeCheckError {
	maxLength: Int!
	message: String!
	query: Query!
}

type SlugTooLongError {
	maxLength: Int!
	query: Query!
}


type StripeCard {
	brand: String!
	funding: String!
	expMonth: Int!
	expYear: Int!
	last4: String!
}

type StripeCustomer {
	id: String!
	paymentMethods(type: StripePaymentMethodType, endingBefore: String, startingAfter: String, limit: Int): StripePaginatedPaymentMethods!
}

type StripePaginatedPaymentMethods {
	data: [StripePaymentMethod!]!
	hasMore: Boolean!
	nextPage: String
}

type StripePaymentMethod {
	id: String!
	created: DateTime!
	card: StripeCard
	type: StripePaymentMethodType!
}

enum StripePaymentMethodType {
	ACSS_DEBIT
	AFFIRM
	AFTERPAY_CLEARPAY
	ALIPAY
	AU_BECS_DEBIT
	BACS_DEBIT
	BANCONTACT
	BLIK
	BOLETO
	CARD
	CASHAPP
	CUSTOMER_BALANCE
	EPS
	FPX
	GIROPAY
	GRABPAY
	IDEAL
	KLARNA
	KONBINI
	LINK
	OXXO
	P24
	PAYNOW
	PIX
	PROMPTPAY
	SEPA_DEBIT
	SOFORT
	US_BANK_ACCOUNT
	WECHAT_PAY
}

type StripeSetupIntent {
	id: String!
	clientSecret: String!
}

union StripeSetupIntentCreatePayload = StripeSetupIntentCreateSuccess

type StripeSetupIntentCreateSuccess {
	setupIntent: StripeSetupIntent!
	query: Query!
}

type TemplateDoesNotExistError {
	query: Query!
}

enum TimeAggregationGranularity {
	HOURLY
	DAILY
	WEEKLY
	MONTHLY
}

type TimeSeries {
	unit: UnitType!
	data: [TimeSeriesDataPoint!]!
	statistics: TimeSeriesStatistics!
}

type TimeSeriesDataPoint {
	datetime: DateTime!
	value: Int!
}

type TimeSeriesStatistics {
	sum: Int!
}

type TokenDoesNotExistError {
	query: Query!
}

type TokenLimitExceededError {
	query: Query!
}

enum UnitType {
	NO_UNIT
	MILLI_SECONDS
	BYTES
}

"""
URL is a String implementing the [URL Standard](http://url.spec.whatwg.org/)
"""
scalar Url

type User {
	id: ID!
	name: String!
	email: String!
	avatarUrl: String
	createdAt: DateTime!
	organizations(after: String, before: String, first: Int, last: Int): OrganizationConnection!
	organizationMemberships: [Member!]!
	personalAccount: PersonalAccount
	limits: ViewerLimits! @deprecated(reason: "Moved to account level")
}

type ValueTooLongError {
	query: Query!
}

type ViewerLimits {
	remainingProjects: Int
	totalProjects: Int
}

schema {
	query: Query
	mutation: Mutation
}

